#!/usr/bin/env python
'''
a program for sequential topography/rocking curve imaging

:author:    Stanislav Stoupin
:email:     sstoupin@gmail.com

:copyright: Copyright 2014 by XSD, Advanced Photon Source, Argonne National Laboratory
:license:   UChicago Argonne, LLC Open Source License, see LICENSE for details.
'''

import os, sys
import numpy as np
import scipy as sp
import operator
import time
#
import itertools
from multiprocessing import Pool
from multiprocessing import freeze_support
#################################################
# LOCAL
#from numpy import *
#from pyhdf import *
#from curvestat import *
#from fit1d import *
#from myio import *
#from roll_zeropad import roll_zeropad
#from scipy.linalg import lstsq
#################################################
# GLOBAL
from dtxrd.pyhdf import *
from dtxrd.curvestat import *
from dtxrd.fit1d import *
from dtxrd.myio import *
from dtxrd.roll_zeropad import roll_zeropad

#from __future__ import division
#from matplotlib.patches import Patch
#import matplotlib.image as mpimg # drop this for PIL
from PIL import Image
from pylab import *
#
#import matplotlib.style
#import matplotlib.pyplot as plt
import matplotlib as mpl
mver = mpl.__version__
ver_check = mver.split('.')
if float(ver_check[0]) >= 2:
    #mpl.style.use('classic')
    #-------------------------------
    ##########################################################
    ## to undo changes in matplotlib 2.1.0
    ##########################################################
    #mpl.rcParams['legend.fancybox'] = False
    #mpl.rcParams['legend.loc'] = 'upper right'
    #mpl.rcParams['legend.numpoints'] = 2
    #mpl.rcParams['legend.fontsize'] = 'large'
    #mpl.rcParams['legend.framealpha'] = None
    #mpl.rcParams['legend.scatterpoints'] = 3
    #mpl.rcParams['legend.edgecolor'] = 'inherit'
    mpl.rcParams['figure.figsize'] = [8.0, 6.0]
    mpl.rcParams['figure.dpi'] = 80
    mpl.rcParams['savefig.dpi'] = 100
    mpl.rcParams['font.size'] = 12
    mpl.rcParams['legend.fontsize'] = 'small'
    mpl.rcParams['figure.titlesize'] = 'medium'
    mpl.rcParams['image.cmap'] = 'jet'
##################################################################
user_dir = os.getcwd()
mpl.rcParams["savefig.directory"] = os.chdir(user_dir)
##################################################################
## fixed constants
##################################################################
r2d=180.0/pi
ftsize = 18         # figure title font size 
sig2fwhm = 2.0*sqrt(2.0*log(2.0)) # =~2.355
##################################################################

__version__='0.09'
prog = os.path.basename(sys.argv[0])
proginfo = prog + __version__ + ', by Stanislav Stoupin <sstoupin@gmail.com>'

#######################################################################################
# HISTORY
#######################################################################################
# 0. added gaussian fit for noisy data as an option "-g" v 0.2
# 1. need deglitching algorithm - done v 0.4
# 2. -b - custom background done v 0.4
# 3. calculate RMS and PV - done in v0.3
# 4. convenient output  done in v 0.3
# 5. a bug fixed with image orientation v 0.4 - for some reason the arrays have to be 
# transposed  v0.4
# 6. introduced colormap range factor (-f _value_  option)
# 7. statistics for selected rectangular region implemented   done v 0.6
# 9. need to sort data for every pixel based on angle values! done v 0.5
# 10. added upper limit on dyn_range (fixed value) 	      done v 0.51
# 11. added search for peak index to improve gaussian fit     done v 0.52
# 12. move dyn_range and other constants to the beginning
#	introduce df as an input parameter to the parser      done v 0.61
#	deglitch by default				      done v 0.63
# 	improve threshold upper limit processing	      done v 0.63
#       subtract bkg from peak data                           done v 0.63
#       add bkg0 - dark current 			      done v 0.64
# 13. improve glitch and background determination (4 points)  done v 0.65
# v 066  fliplr applied to flip left to right so that the images show up as the 
#        incident beam sees them
#        added sample name to report plot as an option
# v067   additional pixel rejection criteria based on the bkg level and on the 
#        COM and FWHM values (worked with Si 220 transmission data)
#        eventually best way to reject bad pixels - just treshold (e.g. -t 1.2)
# v068   added support for hdf5 files 
#        introduced instrument files ccd.py
# v069   minor iteration to adapt to data from topolab (Tim Madden's CCD)
# v070   added a capability to extract and plot slices
#        rearrangement of output files - now separate files for statistics and map data
# v071   fixed input for rotated matrixes 
#        now absence of transpose card processes images which correspond to as collected
#        data - the image is rotated in the data acquisition software so that the desired 
#        is obtained and this orientation is preserved with absence of transpose (-s) 
#        card in the processed rocking curve maps
# v072   added command line to the bottom of the main figure
# v073   switched rollzeropad to global import
# v074   disable writing map data with -o option 
#        -w option only makes sense when saving slices
# v075   when importing modules point to user_dir through os.getcdw()
#        append to path and when import is done exclude sys.path.pop()
# v076   introduced calculation for total rocking curve over the selected region 
#        output for prcurve(pixel) and trcurve(total/region) in the same file
# v077   improve logic on handling integrated reflectivity (now possible to integrate 
#        and normalize)
# v078   began work on implementing transmissivity measurements
# v079   further changes in handling TC data: 
#        background rejection on overall baseline transmissivity (bkg0) and 
#        the strength of the effect (tr ~ 0.01)
# v080   now processing forward diffracted topographs (transmission) 
#        with an option -c (--conduct)
# v081   now can process sequence of tiff (or other image) files using an external angular
#        scale from first column of a data file e.g. SPECfile.dat (-e SPECfile.dat)
# v082   linear interpolation for the background
# v083   found that simps failed on one of the samples NDT111-3_Bc2
#        modified curvestat to avoid simps - just using plain sums now
# v084   changed IOError, e: to IOError as e:
# v085   now rcurve_tot calculated after pixel rejection which is more correct 
#        the result is less dependent on the choice of region
# v086   making cosmetic changes, adapting for python3
# v087   transition from ancient optik parser to argparse
# v088   write processed data to h5 file "-j" option
# v089   remove integration for z = 1 (or z >1) option - to plot raw peak reflectivity counts
# v090   remove list of input files from "param" and write it to h5 file
# v091   began attempt to onclick local rocking curve
# v092   onclick access to RC data at each point - now working
# v093   some improvements to the double for loop, suppress some messages (introduce --diag option)
# v100   attempt to vectorize operations
# v0.01  success with zero crossing (for fwhdm) and vandermonde(gaussian), deglitching via median filtering
# v0.02  various small fixes, made zero crossing compatible with python 3.5 
#        vandermonde/gaussian is still incompatible, no take_along_axis function 
# v0.03  cosmetic changes to output, changes to onpick curve analysis (now shows result with bkg removed)
# v0.04  curve statistics method using zero crossings moved to separate subroutine curvestat_
# v0.05  cosmetic fix in returning the original command line '-r' option
#        now using PIL for reading/writing graphic files          
#        now can import 1-column files with '-e' option
# v0.06  switch data - > data1 for onclick, del data (once range of interest is extracted)
#        fix bug with param for when '-r' is not specified 
# v0.07  rearranged image processing, clipping goes immediately after binning for each image 
#        the unclipped combined dataset is no longer held in memory
# v0.08  Gaussian and Lorentzian curve fitting using multiple cores
#        plotting Lorentzian, getting rid of redundant arrays in memory
#        revised calculation of the total RC, more elegant using masked arrays
#        fixed things so tutorial with hdf4 can run
#        changes in curvestat_ to improve accuracy of thneg, thpos, now closer to point-by-point algo (curvestat)
# v0.09  Now most options can be assigned through file ccd.py
#################################################################################################################
#  TODO LIST
#################################################################################################################
# 0. improve comput. speed? - DONE
# 1. unified input config file for a program run
#################################################################################################################
#------------------------------------------------------------------------------------
# fitting subroutines
#------------------------------------------------------------------------------------

def residuals(p,y,x):
        return y-gauss(p,x)
        
def residuals0g(p,y,x):
        return y-gauss0(p,x)
        
def residuals0l(p,y,x):
        return y-lorentz0(p,x)

def run_multiprocessing(func, i, n_processors):
    with Pool(processes=n_processors) as pool:
        return pool.map(func, i)
    #    
def gfit(args):
    ind,th0,fwhm0,ugol,rcmax_0,rcurve_0 = args
    shape0 = rcmax_0.shape
    j,i = ind
    p0 = [rcmax_0[j,i],th0[j,i],sqrt(2.0)*(fwhm0[j,i]/sig2fwhm)] #bkg max center    
    p, unc, dte, stat, cov = fit1d(residuals0g,p0,ugol,rcurve_0[:,j,i])         
    return p
    
def lfit(args):
    ind,th0,fwhm0,ugol,rcmax_0,rcurve_0 = args
    shape0 = rcmax_0.shape
    j,i = ind
    p0 = [rcmax_0[j,i],th0[j,i],(fwhm0[j,i]/2.0)] #bkg max center    
    p, unc, dte, stat, cov = fit1d(residuals0l,p0,ugol,rcurve_0[:,j,i])         
    return p
#------------------------------------------------------------------------------------
# Error definitions
#------------------------------------------------------------------------------------
def fatalError(msg):
        sys.stderr.write('Error: ')
        sys.stderr.write(str(msg)) 
        sys.stderr.write('\n')
        sys.exit(1)

def fatalIOError(err):
        if issubclass(err.__class__, IOError) and err.strerror and err.filename:
                  err = '%s: %s' % (err.strerror, err.filename)
        fatalError(err)
#------------------------------------------------------------------------------------------------------------------------------------
# Parser 
#------------------------------------------------------------------------------------------------------------------------------------                                                                
def ParseArguments():
        import argparse   # requires Python 2.7 or higher
        msg = prog + '  version: ' + __version__ + '\n'*2 + __doc__.strip()+'\n'
        parser = argparse.ArgumentParser(prog=prog, description=msg, formatter_class = argparse.RawDescriptionHelpFormatter)
        #
        parser.add_argument('-v', '--version', action='version', version=__version__)
        parser.add_argument('-o', '--output', action='store', dest='output', default=None, metavar='FILENAME',
                help='write calculated parameters to a file (defaults to stdout); also, write output for 1pix_total.dat')
        parser.add_argument('-w', '--write', action='store', dest='write', default=None, metavar='FILENAME',
                help='write data to a file (default: do not write) - reserved for slice data')
        parser.add_argument('--hdf5', action='store', dest='hdf5', default=None, metavar='FILENAME',
                         help='save arrays and other parameters to HDF5 metafile (default: do not write)')
        parser.add_argument('-j', '--tif', action='store_const', dest='tif', const=1, default=0, 
                         help='save RC topographs as tif datafiles (default: do not save)') 
        parser.add_argument('--rbin', action='store', dest='rbin', default=None, metavar='N',
                         help='image binning NxN')                                                          
        parser.add_argument('-t', '--threshold', action='store', dest='tr', default=None, metavar='CONST',
                help='intensity threshold (signal relative to bkg) to define boundaries for plotting (default = 1.05)')
        parser.add_argument('-b', '--background', action='store', dest='bkg', default=None, metavar='CONST',
                help='manual assignment of background to a constant, typically dark current of area detector')
        parser.add_argument('-a', action='store', dest='ashift', default=0, metavar='CONST',
                help='compensate beam shift in the imaging plane at a distance CONST [m] (experimental option)')
        parser.add_argument('-r', '--range', action='store', dest='rng', default='-1 -1 -1 -1', metavar='STRING',
                help='range selected for analysis STRING=\'x1 x2 y1 y2\' ')
        parser.add_argument('-x', '--xslice', action='store', dest='xsl', default=-1, metavar='CONST',
                help='slice and plot distribution at a fixed coordinate X')
        parser.add_argument('-y', '--yslice', action='store', dest='ysl', default=-1, metavar='CONST',
                help='slice and plot distribution at a fixed coordinate Y')
        parser.add_argument('-n', '--name', action='store', dest='nm', default=None, metavar='STRING',
                help='sample name')
        parser.add_argument('-f', '--factor', action='store', dest='f', default=None, metavar='CONST',
                help='scale factor for colormap range on FWHM and STDEV topographs')
        parser.add_argument('-m', '--magnify', action='store', dest='m', default=None, metavar='CONST',
                help='scale factor for colormap range on COM, Midpoint, Left Slope and Right Slope topographs')
        parser.add_argument('-d', '--deglitch', action='store', dest='degl', default=None, metavar='CONST',
                help='deglitch data using median filtering, -d CONST, where CONST is the size of the filter window (e.g. 3, 5, ...)')        
        parser.add_argument('--stat', action='store', dest='stat', default=None, metavar='flag',
                         help='perform curve fitting using flag g for Gaussian, l for Lorentzian') 
        parser.add_argument('--nproc', action='store', dest='nproc', default=None, metavar='CONST',
                         help='number of processor cores for fitting (default: 4)')                        
        parser.add_argument('-s', '--trasnpose', action='store_const', const=1, dest='transpose', default=0,
                help='transpose images for plotting')
        parser.add_argument('-u', '--units', action='store', dest='units', default=None, metavar='uname',
                help='angular units: deg, arcsec, urad')
        parser.add_argument('-p', '--publish', action='store_const', const=1, dest='publish', default=0,
                help='generate additional figures (execute instructions in file figures.py)')
        parser.add_argument('-c', '--conduct', action='store_const', const=1, dest='conduct', default=0,
                help='process diffraction images collected in transmission')        
        parser.add_argument('-i', '--instrument', action='store_const', const=1, dest='config', default=None,
                help='read parameters from configuration file ccd.py')        
        parser.add_argument('-z', '--integrate', action='store', dest='z', default=None, metavar='CONST',
                help='presentation of reflectivity data: \n'
                + 'z == 0  - plot peak reflectivity normalized by max. value (default) \n'
                + 'z == -1 - plot integrated reflectivity normalized by max. value \n'
                + 'z !=0 and z !=-1 - raw reflectivity data normalized by input parameter CONST')
        parser.add_argument('-e', '--external', action='store', dest='external', default=None, metavar='FILENAME',
                help='read angular steps from 1st column of an ASCII file (e.g., SPEC scan)')
        parser.add_argument('--diag', action='store_const', const=1, dest='diag', default=0,
                help='show diagnostics messages/figures')
        #
        parser.add_argument('input_files',nargs='+',
                help='list of input filenames')
        return parser.parse_args()
###############################################################################                                                                
def main():
  opts = ParseArguments()
  if opts.output is not None:
     try:
        outFile = open(opts.output, 'w')
     except IOError as e:
        fatalIOError(e)
  else:
     outFile = sys.stdout
  #----------------------------------------------------
  # begin entries in outFile   
  outFile.write(prog + ' v '+__version__+'\n')
  #################################################### 0.05 fix
  nall = len(sys.argv)-len(opts.input_files)
  param0 = sys.argv[0:nall]  
  if opts.rng == '-1 -1 -1 -1':
    param = ' '.join(param0)
  else: 
    for p,i in zip(param0,arange(0,len(param0))):
      if p == '-r':
        ind_r = i        
    param1 = ' '.join(param0[0:ind_r+1])
    param2 = ' '.join(param0[ind_r+2:])
    param = param1 + ' '+repr(param0[ind_r+1])+' '+param2
  ###############################################################
  #----------------------------------------------------- 
  # initialize & set constants      
  #-----------------------------------------------------
  alldata=[]
  data=[]
  th_deg=[]
  nf=len(opts.input_files)  # number of input files
  fn_ = opts.input_files
  rng = opts.rng
  cstat = opts.stat 
  
  if opts.diag == 1:
      print("Number of files to analyze = ", nf)
      
  #populate some parameters with default values    
  rbin=1             # binning
  zf = 0             # card for intensity representation
  tr = 1.05          # lower threshold
  dx, dy = 1.0, 1.0  # CCD camera pixel size [mm]    
  uf = 'deg'         # units
  nproc = 4          # number of processor cores for fitting (pixel-by-pixel)
  fn_ang = opts.nm   # sample name
  df = opts.degl          # deglitching option
  #
  sample_name = opts.nm
  bkg = opts.bkg
  trans = opts.transpose # image array transpose card
  conduct = opts.conduct # card to use if images are collected in transmission 
  sf = 1.0               # colorbar scaling on FWHM STDEV
  mf = 1.0               # colorbar scaling on COM, thmid, thneg and thpos
  dyn_range = 1.0e6      # upper threshold on the intensity colorbar (for plotting) 
  fwhm_0 = 30.0          # initial fwhm guess (for fitting) 
  bkg0 = 2750.0          # a "reasonable guess" background - dark current count       
  # default paths in hdf or h5 file    
  data_path='/entry/instrument/detector/data'
  th_path='/entry/instrument/detector/NDAttributes/theta'
  chi_path='/entry/instrument/detector/NDAttributes/chi'
  #-------------------------------------------------------------------------------------------
  if opts.config is not None:  # if config file is used (e.g., ccd.py)
    user_dir = os.getcwd()
    sys.path.append(user_dir)
    # try extracting parameters from ccd.py file:
    # import data 
    try:    from ccd import data_path
    except: print('data_path is not found int the config file')    
    try:    from ccd import th_path
    except: print('th_path is not found int the config file')
    try:    from ccd import chi_path
    except: print('chi_path is not found int the config file')
    try:    from ccd import fn_ang
    except: print('fn_ang is not found in the config file')
    # calculation parameters
    try:    from ccd import rbin
    except: print('rbin is not found in the config file')    
    try:    from ccd import dx,dy 
    except: print('either dx or dy are not found in the config file')
    try:    from ccd import zf
    except: print('zf is not found in the config file')    
    try:    from ccd import rng
    except: print('rng is not found in the config file')      
    try:    from ccd import cstat
    except: print('cstat is not found in the config file')                    
    try:    from ccd import uf
    except: print('uf is not found in the config file')
    try:    from ccd import trans
    except: print('trans is not found in the config file')
    try:    from ccd import conduct
    except: print('conduct is not found in the config file')
    try:    from ccd import df
    except: print('df is not found in the config file')
    try:    from ccd import nproc
    except: print('nproc is not found in the config file')
    try:    from ccd import bkg
    except: print('bkg is not found in the config file')
    # parameters for plotting
    try:    from ccd import tr
    except: print('tr is not found in the config file')     
    try:    from ccd import dyn_range
    except: print('dyn_range is not found in the config file')
    try:    from ccd import fwhm_0 
    except: print('fwhm_0 is not found in the config file')            
    try:    from ccd import bkg0     
    except: print('bkg0 is not found in the config file')
    try:    from ccd import sf
    except: print('sf is not found in the config file')
    try:    from ccd import mf
    except: print('mf is not found in the config file')            
    try:    from ccd import sample_name
    except: print('sample_name is not found in the config file')
    sys.path.pop()      
  else:
    outFile.write('Configuration file is not used. Demonstration mode: default values are used for certain parameters \n')
  #----------------------------------------------------------------------------------------------  
  # overwrite parameters (even if extracted from ccd.py) if non-default values assigned by command line    
  if opts.rbin is not None: rbin = int(opts.rbin)
  if opts.rng != '-1 -1 -1 -1': rng = opts.rng
  if opts.stat is not None: cstat = opts.stat
  if opts.tr is not None: tr = float(opts.tr)
  if opts.z is not None: zf = int(opts.z)
  if opts.degl is not None: df = abs(int(opts.degl))
  if opts.external is not None: fn_ang = opts.external
  if opts.f is not None: sf = float(opts.f)
  if opts.m is not None: mf = float(opts.m)
  if opts.units is not None: uf = opts.units
  if opts.transpose != 0:   trans = opts.transpose
  if opts.conduct !=0: conduct = opts.conduct
  if opts.nproc is not None: nproc = int(opts.nproc)   #number of processors 
  if opts.nm is not None: sample_name = opts.nm
  if opts.bkg is not None: bkg = float(opts.bkg)
  #----------------------------------------------------------------------------------------------
  outFile.write('range for analysis (x1 x2 y1 y2): (%s)  ' % rng + '\n')
  ###############################################################################################
  #assign pixel size:  
  dx=float(rbin)*dx
  dy=float(rbin)*dy
  ## extract angular scale from an external data file
  #if opts.external is not None:
  if fn_ang is not None:
    #fn_ang = str(opts.external) # read scan ascii file (SPEC scan or other)
    fn_ang = str(fn_ang)
    d1,d2=readFile(fn_ang)
    checkext = fn_ang.split('.')
    if checkext[1] == 'asc':
        angle_v = 1.0*d2[:,1]
    else: 
        angle_v = 1.0*d2[:,0] # works with 1-column data, tested
  ######################################################################################################  
  # READ IMAGE SEQUENCE, SELECT METHOD BASED ON FILE EXTENSION
  ######################################################################################################
  # read the first input file to extract reference file size
  fn0 = fn_[0]
  fn0_ext=fn0.split(".")[-1]
  if fn0_ext == "hdf":
      angle0, size0, im0 = read_hdf4(fn0)
      dx = 0.06; dy = 0.06 # it is essential to know these at this stage (used to calculate ROI range)
  elif fn0_ext == "h5":
      angle0, chi0, size0, im0 = read_hdf5(fn0,rbin,data_path,th_path,chi_path)
  elif fn0_ext == "tiff" or fn0_ext == "tif" or fn0_ext == "png" or fn0_ext == "jpg" or fn0_ext == "jpeg":
        size0, im0 = read_img(fn0,rbin)
  if trans == 0:
        nx=size0[1]
        ny=size0[0]
  else:         
        nx=size0[0]
        ny=size0[1]
  ####################################################
  ## SELECT REGION OF INTEREST
  ####################################################
  step=1
  rangexy=rng.split(' ')    
  rngx1=float(rangexy[0]); rngy1=float(rangexy[2])
  rngx2=float(rangexy[1]); rngy2=float(rangexy[3])
  #  
  if rngx1<0:
    indx1=0
  else:
    indx1=int(round(rngx1/dx))
  if rngy1<0:
    indy1=0
  else:
    indy1=int(round(rngy1/dy))
  #---------------------------------------  
  if rngx2<0 or rngx2>nx*dx:
    indx2=nx
  else:  
    indx2=int(round(rngx2/dx))
  if rngy2<0 or rngy2>ny*dy:
    indy2=ny
  else:
    indy2=int(round(rngy2/dy))        
  #
  xrange=arange(nx-indx2,nx-indx1,step) #;print "xrange = ", xrange
  yrange=arange(ny-indy2,ny-indy1,step) #;print "yrange = ", yrange
  #print("xrange = ", xrange)
  #print("yrange = ", yrange)  
  nx1 = indx2-indx1
  ny1 = indy2-indy1    
  #######################################################################################################
  outFile.write("image size to be analyzed : "+str(nx1)+'x'+str(ny1) + '\n')
  #-----------------------------------------------------------------------------------------------------
  # now for every file:  
  fn_count = 0 
  for fn in fn_:   
    fn_ext=fn.split(".")[-1]
    if fn_ext == "hdf":
        angle, size, im = read_hdf4(fn)
        chi = 'N/A'
        dx=0.06; dy=0.06
    elif fn_ext == "h5":
        angle, chi, size, im = read_hdf5(fn,rbin,data_path,th_path,chi_path) 
    #  
    elif fn_ext == "tiff" or fn_ext == "tif" or fn_ext == "png" or fn_ext == "jpg" or fn_ext == "jpeg":        
        size, im = read_img(fn,rbin)          
        chi = 'N/A'
        angle = angle_v[fn_count]
    else:
      fatalError('Supported image files are: HDF4 (.hdf), HDF5 (.h5), images (.tif, .tiff, .png, .jpg, .jpeg)')  
    # confirm size matching
    if size != size0:
        fatalIOError('The sequence contains images of different size. Processing aborted.')
    # transform images                 
    if trans == 0:
        im=transpose(im)
        im=fliplr(im)
        nx=size[1]
        ny=size[0]
    else:             
        nx=size[0]
        ny=size[1]
        im=flipud(im)
# 
    if opts.diag == 1: 
        print("nx = ", nx)
        print("ny = ", ny)
        print("filename: ", fn)
        print("fn_count: ", fn_count)
        print("theta = ", angle)
        print("chi = ", chi)
    ## clip image, add to the combined dataset ###############
    im = im[yrange[0]:yrange[-1]+1,xrange[0]:xrange[-1]+1]
    data_fn=[angle,im]
    alldata=alldata+[data_fn]
    fn_count = fn_count + 1
  # sort by angle ##########################
  alldata=sorted(alldata,key=operator.itemgetter(0))  
  #################################################    
  # convert angular scale    
  for x in alldata:
    th_deg=th_deg+[x[0]]            
  #-----------------------------------------------------------
  if uf == 'deg':
    th=1.0e6*array(th_deg)/r2d                # th_deg in degrees
  elif uf =='arcsec':
    th=1.0e6*array(th_deg)/(60.0)**2.0/r2d    # th_deg in arcseconds
  elif uf =='urad':
    th=array(th_deg)                          # th_deg in urad
  elif uf =='um':
    th=5.86*array(th_deg)                     # th_deg in microns
  elif uf =='volt':
    #th=22.1388*array(th_deg)                 # th_deg in microns
    th=26.5*array(th_deg)
  else: 
    fatalIOError("Unknown angular units chosen")
################################################################################
## theta origin is defined here as the center of the angular range in the scan 
################################################################################
  th_beg=th[0]
  th_end=th[-1]
  th0=0.5*(th_beg+th_end)  
  th0_deg=1.0e-6*r2d*th0
  #----------------------------------------------------------------------------
  ugol=th-th0  
  outFile.write("th0 (center of angular range) [urad] = "+ str(th0) + '\n')

  if opts.ashift == 0:
     for x in alldata:
         data=data+[x[1]]
  else:
     from ccd import th0
     #from roll_zeropad import roll_zeropad
     for (t,x) in zip(th,alldata): 
        imdist = float(opts.ashift) # [m]
        imsh = 1.0e-6*(t-th0)*imdist*1.0e3 # image shift [mm]
        print("applied shifts [mm] =  ", imsh)
        print("th0 [urad] = ", th0)
        rind = int(imsh/dy); print("rind = ", rind)
        #sarray = roll(x[1],-rind,axis=0)
        sarray = roll_zeropad(x[1],-rind,axis=0)        
        data = data +[sarray]
  # convert data to array                                                                 
  del alldata
  data1 = np.asarray(data,dtype=float32); #print data
  del data
####################################################
  abs_max=data1.max()  
  if opts.diag == 1: 
      print("size of rebinned data = ", data1.shape)  
      abs_max=data1.max()
      print ('abs_max = ', abs_max)
#-------------------------------------------------------  
#  CALCULATION OF TOPOGRAPHS
#-------------------------------------------------------
  timing_start = time.time()
  const = ones(data1.shape[0],dtype=float32) # this is ones along 0 dimension of 3D data array
  ### deglitching using median filter #######################################
  if df is not None:
      from scipy.signal import medfilt
      #df = abs(int(opts.degl))
      data1 = medfilt(data1,kernel_size=(df,1,1))
  ###########################################################################      
  th_ = ugol[...,newaxis,newaxis]*ones(data1.shape)   # extend to 3D
  if bkg is None:  # now as array
      print("bkg approximated by the endpoints")
      bkg_2d = 0.25*(data1[0,:,:] + data1[1,:,:] + data1[-2,:,:] + data1[-1,:,:])
      bkg_ = const[...,newaxis,newaxis]*bkg_2d[newaxis,...]  # this is 3D background unique for each pixel
      #
      b1_2d = 0.5*(data1[0,:,:] + data1[1,:,:])
      b2_2d = 0.5*(data1[-2,:,:] + data1[-1,:,:])
      A_2d = (b2_2d - b1_2d)/(th_end - th_beg)
      B_2d = b2_2d - A_2d*ugol[-1]
      #
      A_ = const[...,newaxis,newaxis]*A_2d[newaxis,...]  # 3D unique for each pixel
      B_ = const[...,newaxis,newaxis]*B_2d[newaxis,...]  # 3D unique for each pixel    
      
  else: 
      print("bkg is assigned through option, bkg = ", bkg)
      bkg_=bkg*ones(data1.shape) 
      bkg_2d = bkg*ones((data1.shape[1],data1.shape[2]))
      A_ = zeros(data1.shape)
      B_ = bkg_   
  #################################################################################
  #################################################################################
  if conduct == 1:
      baseline_ =  A_*th_ + B_           # 3D baseline unique for each pixel, 2 point linear interpolation for each pixel
      rcurve_ = -1.0*(data1 - baseline_)  # TC
      bkgs_ = zeros(data1.shape)          # TC  
      #
      rcmax_ = amax(rcurve_, axis=0) # TC this is 2D array of actual max. for each pixel      
      #rmax_=rcmax_                   # TC general /maximum without background, don't really need it, now calculated in curvestat_
      #
      if zf == 0: peak = rcmax_/bkg_2d  # for more precise quantitative refl. measurement need to normalize by baseline_(max_position) #TC 
      elif zf == -1: peak = sum((rcurve_ - bkgs_),axis=0)*(th[-1] - th[0])/float((len(th)-1))/bkg_2d    # same as comment above #TC
      else: peak = rcmax_/abs(float(zf))                                                                         #TC      
      
  elif conduct == 0:
      rcurve_ = data1
      bkgs_ = bkg_                      #RC
      rcmax_ = amax(rcurve_, axis=0)  # 2D
      #rmax_ = rcmax_ - bkg_2d # RC    # 2D, don't need (calculated in curvestat_)
      #
      if zf == 0: peak = rcmax_
      elif zf == -1: peak = sum((rcurve_ - bkgs_),axis=0)*(th[-1] - th[0])/float((len(th)-1))
      else: peak = rcmax_/abs(float(zf))       
  else: fatalIOError('conduct card (must be either 1 or 0)')  
  del data1   # no longer required
  rcurve_0 = rcurve_ - bkgs_  # background subtracted
  peak_ind = argmax(rcurve_0,axis=0) # 2D array of peak indicies
  del rcurve_   # all further calculations are performed with subtracted background (rcurve_0)
  ##################################################################################################################  
  # for all types of processing run zero-crossing algorithm
  thneg,thpos,thmid,fwhm,com,stdev = curvestat_(ugol,rcurve_0)
  #    
  if cstat is not None:   
    rcmax_0 = amax(rcurve_0, axis=0)  # 2D
    shape0 = rcmax_0.shape
    xr = range(len(xrange))
    yr = range(len(yrange))
    index_list = list(itertools.product(yr,xr))
    #n_processors = nproc  # number of processor cores
    #
    if opts.diag == 1: print("Input length: {}".format(len(index_list)))        
    args = [(k,thmid,fwhm,ugol,rcmax_0,rcurve_0) for k in index_list]
    if cstat == 'g':
        p = run_multiprocessing(gfit,args,nproc)                        
        if opts.diag == 1: print("Output length: {}".format(len(p)))
        p = array(p)
        p0 = reshape(p[:,0],shape0)
        p1 = reshape(p[:,1],shape0)
        p2 = reshape(p[:,2],shape0)    
        thmid = p1                        # midpoint for Gaussian is the p1 parameter by definition
        #com = p1                          # also the center of mass
        #stdev = abs(p2)/sqrt(2.0)         # standard deviation is the p2/sqrt(2) by definition
        fwhm = 2.0*abs(p2)*sqrt(log(2.0)) # FWHM is derived 
        thneg = p1 - fwhm/2.0             # by definition 
        thpos = p1 + fwhm/2.0             # by definition
        del p
    elif cstat == 'l':
        p = run_multiprocessing(lfit,args,nproc)        
        if opts.diag == 1: print("Output length: {}".format(len(p)))
        p = array(p)
        p0 = reshape(p[:,0],shape0)
        p1 = reshape(p[:,1],shape0)
        p2 = reshape(p[:,2],shape0)    
        thmid = p1                        # this is midpoint by definition
        #com = p1                          # COM is not defined for Lorentzian (infinity)
        #stdev = 2.0*abs(p2)               # STDEV is not defined for Lorentzian (infinity)
        fwhm =  2.0*abs(p2)               # by definition
        thneg = p1 - fwhm/2.0             # lets define it like that
        thpos = p1 + fwhm/2.0             # lets define it like that
        del p    
    #if __name__ == "__main__":        
    #  freeze_support()
    #  main()
##########################################################################################
# Apply masks based on thresholds, common for all for now
##########################################################################################
  rcmax_=fliplr(rcmax_)
  #rmax_=fliplr(rmax_) don't need that because rcmax_ is plotted everywhere
  peak=fliplr(peak)
  fwhm=fliplr(fwhm)
  stdev=fliplr(stdev)  
  thmid=fliplr(thmid) 
  com=fliplr(com) 
  thneg=fliplr(thneg)
  thpos=fliplr(thpos)  
  ##################################################################################################################
  # COMMON for all options, intensity peak and masked peak array
  ##################################################################################################################
  peak_m0 = ma.masked_where(rcmax_<tr*bkg_2d, peak)  # masked array, correct syntax
  peak_m1 = ma.masked_where(rcmax_>dyn_range*bkg_2d, peak_m0, copy=False)  # masked array, correct syntax
  peak_m2 = ma.masked_where(abs(fwhm)>abs(th_end - th_beg), peak_m1, copy=False)  
  
  #peak = where((rcmax_<tr*bkg_2d),1e9,peak)                                    # do I need this? likely not
  #peak = where((rcmax_>dyn_range*bkg0),1e9,peak)                               # do I need this? likely not
###################################################################################################################
  com_m0 = ma.masked_where(rcmax_<tr*bkg_2d, com)
  com_m1 = ma.masked_where(rcmax_>dyn_range*bkg0, com_m0, copy=False)
  com_m2 = ma.masked_where(abs(fwhm)>abs(th_end - th_beg), com_m1, copy=False)
  #
  stdev_m0 = ma.masked_where(rcmax_<tr*bkg_2d, stdev) 
  stdev_m1 = ma.masked_where(rcmax_>dyn_range*bkg0, stdev_m0, copy=False) 
  stdev_m2 = ma.masked_where(abs(fwhm)>abs(th_end - th_beg), stdev_m1, copy=False)
  #
  fwhm_m0 = ma.masked_where(rcmax_<tr*bkg_2d, fwhm)
  fwhm_m1 = ma.masked_where(rcmax_>dyn_range*bkg0, fwhm_m0, copy=False)
  fwhm_m2 = ma.masked_where(abs(fwhm)>abs(th_end - th_beg), fwhm_m1, copy=False)
  #
  thmid_m0 = ma.masked_where(rcmax_<tr*bkg_2d, thmid)
  thmid_m1 = ma.masked_where(rcmax_>dyn_range*bkg0, thmid_m0, copy=False)
  thmid_m2 = ma.masked_where(abs(fwhm)>abs(th_end - th_beg), thmid_m1, copy=False)
  #
  thneg_m0 = ma.masked_where(rcmax_<tr*bkg_2d, thneg)
  thneg_m1 = ma.masked_where(rcmax_>dyn_range*bkg0, thneg_m0, copy=False)
  thneg_m2 = ma.masked_where(abs(fwhm)>abs(th_end - th_beg), thneg_m1, copy=False)
  #
  thpos_m0 = ma.masked_where(rcmax_<tr*bkg_2d, thpos)
  thpos_m1 = ma.masked_where(rcmax_>dyn_range*bkg0, thpos_m0, copy=False)
  thpos_m2 = ma.masked_where(abs(fwhm)>abs(th_end - th_beg), thpos_m1, copy=False)
  
  #############################################################################################
  outFile.write("Calculation of RC topographs complete in %f seconds" % (time.time() - timing_start) +'\n')
  #############################################################################################
  # Flattened arrays for the region of interest to calculate statistics  
  peak1 = peak_m2.flatten()
  fwhm1 = fwhm_m2.flatten()
  stdev1 = stdev_m2.flatten()
  com1 = com_m2.flatten()
  thmid1 = thmid_m2.flatten()
  thneg1 = thneg_m2.flatten()
  thpos1 = thpos_m2.flatten()
  #---------------------------------------------------------------------  
  # Normalization of intensity depending on the requested metrics
  norm1=amax(peak_m1)  
  norm2=amax(peak_m2)
  outFile.write("Norm. factor (max. Intens.) = "+str(norm2) +'\n')
  # Average background subtracted:
  bkg_aver = sum(bkg_2d)/float(bkg_2d.shape[0]*bkg_2d.shape[1])
  outFile.write("Average baseline subtracted, bkg_aver = " + str(bkg_aver) + '\n')
  #
  if conduct == 0:
    if zf == 0 or zf == -1:
      peak=peak/norm1 
      peak1=peak1/norm1
      peak_m1 = peak_m1/norm1
      peak_m2 = peak_m2/norm2
  elif conduct == 1:
    if zf == -1:
      peak=peak/norm1 
      peak1=peak1/norm1
      peak_m1 = peak_m1/norm1
      peak_m2 = peak_m2/norm2        
  #########################################################################################    
  # calculate statistics and fill output           
  # Note: names like parametername0 are reserved for stats, don't use for other things
  #
  out='------------------------------------------------------------------------\n'
  #----------------------------------------------------------------------------------
  fwhm0=average(fwhm1);            out = out + "FWHM_average = %f " % fwhm0 +" urad\n"
  fwhm_rms=std(fwhm1);             out = out + "FWHM_rms = %f "     % fwhm_rms +" urad\n"
  fwhm_pv=amax(fwhm1)-amin(fwhm1); out = out + "FWHM_pv =  %f "     % fwhm_pv +" urad\n"
  #----------------------------------------------------------------------------------
  stdev0=average(stdev1);             out = out + "STDEV_average = %f " % stdev0 +"urad\n"
  stdev_rms=std(stdev1);              out = out + "STDEV_rms = %f "     % stdev_rms +" urad\n"
  stdev_pv=amax(stdev1)-amin(stdev1); out = out + "STDEV_pv = %f "      % stdev_pv +" urad\n"
  #----------------------------------------------------------------------------------
  peak0=mean(peak1);               out = out + "Intens_average = %f " % peak0 +"\n"
  peak_rms=std(peak1);             out = out + "Intens_rms = %f "     % peak_rms +"\n"
  peak_pv=amax(peak1)-amin(peak1); out = out + "Intens_pv = %f "      % peak_pv +"\n"
  #----------------------------------------------------------------------------------
  com0=average(com1);           out = out + "COM_average = %f " % com0 +" urad\n"
  com_rms=std(com1);            out = out + "COM_rms = %f "     % com_rms +" urad\n"
  com_pv=amax(com1)-amin(com1); out = out + "COM_pv = %f "      % com_pv +" urad\n"
  #----------------------------------------------------------------------------------
  thmid0=average(thmid1);             out = out + "thmid_average = %f " % thmid0 +" urad\n"
  thmid_rms=std(thmid1);              out = out + "thmid_rms = %f "     % thmid_rms +" urad\n"
  thmid_pv=amax(thmid1)-amin(thmid1); out = out + "thmid_pv = %f "      % thmid_pv +" urad\n"
  #----------------------------------------------------------------------------------
  thneg0=average(thneg1);             out = out +"thneg_average = %f " % thneg0 +" urad\n"
  thneg_rms=std(thneg1);              out = out + "thneg_rms = %f "    % thneg_rms +" urad\n"
  thneg_pv=amax(thneg1)-amin(thneg1); out = out + "thneg_pv = %f "     % thneg_pv +" urad\n"
  #----------------------------------------------------------------------------------
  thpos0=average(thpos1);             out = out + "thpos_average = %f " % thpos0 +" urad\n"
  thpos_rms=std(thpos1);              out = out + "thpos_rms = %f "     % thpos_rms +" urad\n"
  thpos_pv=amax(thpos1)-amin(thpos1); out = out + "thpos_pv = %f "      % thpos_pv +" urad\n"
  out = out + '------------------------------------------------------------------------\n'
  #----------------------------------------------------------------------------------
##############################################################################################
## Local (center pixel) and Total rocking curve
##############################################################################################
  # define central pixel                                     
  indx_c = int(round(0.5*nx1)) # nx - int(round(0.5*(xrange[0]+xrange[-1])))
  indy_c = int(round(0.5*ny1)) # ny - int(round(0.5*(yrange[0]+yrange[-1])))
  rcurve_c = rcurve_0[:,indy_c,indx_c]
  #
  result = curvestat(ugol,rcurve_c,0.0)
  th_max00=result[0]; r_max00=result[1]; th_neg00=result[2]; th_pos00=result[3]; th_mid00=result[4]
  fwhm00=result[5]; com00=result[6]; stdev00=sqrt(abs(result[7]))
  print('--------------------------------------------------------------------------------')
  print('Representative local RC at center:')
  print('X0 [mm] = ', float(indx1 + indx_c)*dx)
  print('Y0 [mm] = ', float(indy1 + indy_c)*dy)
  #
  print('Generic FWHM/COM:')
  print('r_max [ct] =  %f' % r_max00)
  print('th_max [urad] = %f' % th_max00)
  print('th_mid [urad] = %f' % th_mid00)
  print('com [urad] = %f' % com00)
  print('stdev [urad] =  %f' % stdev00)
  print('fwhm [urad] = %f'   %fwhm00)  
  # Gaussian fit
  p00=[r_max00,com00,sqrt(2.0)*(fwhm00/2.355)] #bkg max center
  p_c, unc, dte, stat, cov = fit1d(residuals0g,p00,ugol,rcurve_c) 
  #com0=sum((rcurve-p[0])*(ugol))/sum(rcurve-p[0])
  stdev_g = abs(p_c[2])/sqrt(2.0)
  fwhm_g = 2.0*abs(p_c[2])*sqrt(log(2.0))
  #
  print('Gaussian fit:')
  print('r_max_g [ct] =  %f' % p_c[0])
  print('th_max_g [urad] = %f' % p_c[1])
  print('stdev_g [urad] =  %f' % stdev_g)
  print('fwhm_g [urad] = %f'   %fwhm_g)
  # Lorentzian fit
  p00=[r_max00,com00,fwhm00/2.0]
  p_l, unc, dte, stat, cov = fit1d(residuals0l,p00,ugol,rcurve_c)
  #stdev_l = abs(p_l[2])/sig2fwhm, is infinity actually
  fwhm_l = 2.0*abs(p_l[2])
  print('Lorentzian fit:')
  print('r_max_l [ct] =  %f' % p_l[0])
  print('th_max_l [urad] = %f' % p_l[1])
  #print('stdev_l [urad] =  %f' % stdev_l)
  print('fwhm_l [urad] = %f'   %fwhm_l)      
  #--------------------------------------------------------
  prcurve = rcurve_c  
  ##################################################################################              
  # start plotting things ----------------------------------
  mpl.rcParams.update({'font.size': 12})
  f1=plt.figure(figsize=(8.0,7.0))
  plt.plot(ugol,prcurve, 'bo',label="local RC") 
  plt.plot(ugol,prcurve, 'b-')
  plt.plot(ugol,ugol*0, color='k', label='baseline (subtracted bkg)')
  ugol_g=arange(ugol[0],ugol[-1]+0.1,0.1)
  #plt.plot(ugol_g,gauss(p,ugol_g)-p[0],'b--',label="Gauss. fit for local RC")            
  plt.plot(ugol_g, gauss0(p_c,ugol_g),'b--',label="Gauss. fit for local RC")
  plt.plot(ugol_g, lorentz0(p_l,ugol_g),'g--',label="Lorentz. fit for local RC")              
  plt.title ('RC at center pixel [mm]: X ='+str(round((indx1+indx_c)*dx,3))+', Y = '+str(round((indy1+indy_c)*dy,3)),size=16) 
  plt.xlabel('$\\theta - \\theta_0$, [$\mu$rad]', size=16)
  plt.ylabel('Counts', size=16)                                        
  ####################################################################################
  # process and plot total rocking curve
  ####################################################################################
  #apply mask that of peak_m2
  #print('rcurve_0.shape = ', rcurve_0.shape)
  #print('peak_m2.shape = ', peak_m2.shape)
  rcurve_0m2 = ma.array(rcurve_0[:,:,::-1], mask = rcurve_0*peak_m2.mask) # need to fliplr rcurve_0 (peak was fliplr earlier)
  rcurve_1m2 = sum(rcurve_0m2,axis=1)
  rcurve_tot = sum(rcurve_1m2,axis=1)        
  if opts.diag == 1: 
      print('count = ', ma.count(peak_m2))
      print('count_masked = ', ma.count_masked(peak_m2))
  trcurve =  rcurve_tot/ma.count(peak_m2)  # average curve/normalization
  #
  stat=curvestat(ugol,trcurve,0.0)
  #
  fwhm_tot=stat[5];                 out = out + "FWHM_tot = %f " % fwhm_tot +" urad\n"
  stdev_tot=sqrt(abs(stat[7]));     out = out + "STDEV_tot = %f " % stdev_tot +" urad\n"
  #
  if zf == 0:     
      peak_tot = stat[1]/norm2
  elif zf == -1:  
      peak_tot = stat[8]/norm2
  else:               
      peak_tot = stat[1]/abs(zf)
  out = out + "Intens_tot = %f " % peak_tot +"\n"
  #  
  com_tot=stat[6];                  out = out + "COM_tot = %f "   % com_tot +" urad\n"
  thmid_tot=stat[4];                out = out + "thmid_tot = %f " % thmid_tot +" urad\n"   
  thneg_tot=stat[2];                out = out + "thneg_tot = %f " % thneg_tot +" urad\n"  
  thpos_tot=stat[3];                out = out + "thpos_tot = %f " % thpos_tot +" urad\n"       
  #
  plt.plot(ugol,trcurve, 'ro',label="total RC")
  plt.plot(ugol,trcurve, 'r-')
  plt.legend(loc='upper right',fontsize=10)
##################################################################################
## Write output									
##################################################################################
  outFile.write('------------------------------------------------------------------------\n')
  #outFile.write('peak max = '+str(norm)+'\n')
  #outFile.write('threshold = '+str(tr)+'\n')        
  outFile.write('----------------- ROI STATS --------------------------------------------\n')
  outFile.write(out)  
  outFile.close
    
  if opts.output is not None:
      header="# RC from the center pixel \n# columns: angle intensity\n"
      writeFile("prcurve.dat", header, ugol, prcurve)                                                   
      header="# total RC over the selected region \n# columns: angle trcurve\n"
      writeFile("trcurve.dat", header, ugol, trcurve)                                                   
##################################################################################  
##  Plot results
##################################################################################
  # need to "mirror" y indexes because in an array numbering starts from top left corner
  # affects only choice of range - does not affect plotting 
  # same for x since it was found that the image has to be reversed in x direction
  # note that for x fliplr is applied later while for y imshow origin='upper'
  nnx1=nx-indx2; nnx2=nx-indx1
  nny1=ny-indy2; nny2=ny-indy1
#######################################################
## Extract slices
#######################################################  
  xsl=float(opts.xsl)
  ysl=float(opts.ysl)
  if xsl >= 0:
      indxsl = nx-int(xsl/dx) - nnx1
      #      
      peak_sl = peak[:,indxsl]
      fwhm_sl = fwhm[:,indxsl]
      stdev_sl = stdev[:,indxsl]
      com_sl = com[:,indxsl]
      thmid_sl = thmid[:,indxsl]
      thneg_sl = thneg[:,indxsl]
      thpos_sl = thpos[:,indxsl] 
      range_sl = dy*arange(indy1,indy2)
      sbtitle0 = 'Slices at X = '+str(xsl)+'. '
      str_axis='y [mm]'
  #----------------------------------    
  if ysl >= 0:
      indysl = ny-int(ysl/dx) - nny1
      #
      peak_sl = peak[indysl,:]
      fwhm_sl = fwhm[indysl,:]
      stdev_sl = stdev[indysl,:]
      com_sl = com[indysl,:]
      thmid_sl = thmid[indysl,:]
      thneg_sl = thneg[indysl,:]
      thpos_sl = thpos[indysl,:]
      range_sl = dx*arange(indx1,indx2)
      sbtitle0 = 'Slices at Y = '+str(ysl)+'. '      
      str_axis='x [mm]'
  #
  xyrange=(dx*indx1,dx*indx2,dy*indy1,dy*indy2)  # 
  #      
  if xsl >=0: 
      peak_sl=peak_sl[::-1]
      fwhm_sl=fwhm_sl[::-1]
      stdev_sl=stdev_sl[::-1]
      thmid_sl=thmid_sl[::-1]
      com_sl=com_sl[::-1]
      thneg_sl=thneg_sl[::-1]
      thpos_sl=thpos_sl[::-1] 
###################################################################################
## PLOT EVERYTHING
###################################################################################
  fig=plt.figure(figsize=(22.0,12.2))
  if   cstat == 'g':    sbtitle='Gaussian curve fitting.'
  elif cstat == 'l':    sbtitle='Lorentzian curve fitting.'  
  else:                sbtitle='No curve fitting.'
  #      
  sbtitle='Rocking curve topographs: '+sbtitle
  # Sample name     
  if sample_name is not None:       sbtitle=sbtitle+' Sample: '+sample_name  #+'\n' + param  
  plt.suptitle(sbtitle, size=ftsize)      
  #plt.gca().set_position((.1, .1, .1, .1)) # used to be here - now producing weird empty subplot - actually not needed
  plt.figtext(0.1,0.025,param)
  #----------------------------------------------------------------------------------
  ax1 = fig.add_subplot(331)
  if zf == 0:
      imgplot = ax1.imshow(peak_m2, aspect='auto', extent=xyrange,vmin=0,vmax=1.0)
      if conduct == 0:   ax1.set_title('Peak Intens. [n.u.]',size=ftsize)
      elif conduct == 1: ax1.set_title('Peak Intens. [abs.u.]',size=ftsize)   # this is absolute Refl. for low-absorbing sample
      fig.colorbar(imgplot, ax=ax1)
  elif zf == -1:
     imgplot = ax1.imshow(peak_m2, aspect='auto', extent=xyrange,vmin=0,vmax=1.0)
     if conduct == 0:    ax1.set_title('Integrated Intens.[n.u.]',size=ftsize)
     elif conduct == 1:  ax1.set_title('Integrated Intens. [n.u.]',size=ftsize)
     fig.colorbar(imgplot, ax=ax1)      
  else: 
      if conduct == 0:   
          ax1.set_title('Intensity [cnt x 10$^3$]',size=ftsize)
          vmin0=amin(peak1)/1.0e3; vmax0=amax(peak1)/1.0e3
          #peak_tr = 65536.0/abs(zf) #; print ('peak tr = ', peak_tr)  this threshold based on assumption of 16bit detector
          #peak_m9 = ma.array(1.0e-3*peak_m2,mask=peak_m1>peak_tr)            
          imgplot = ax1.imshow(1.0e-3*peak_m2, aspect='auto', extent=xyrange,vmin=vmin0,vmax=vmax0)      
      elif conduct == 1: 
          plt.title('Intensity [cnt x 10$^3$]',size=ftsize)
          vmin0=amin(peak1)/1.0e3; vmax0=amax(peak1)/1.0e3
          imgplot = ax1.imshow(1.0e-3*peak_m2, aspect='auto', extent=xyrange,vmin=vmin0,vmax=vmax0)
      #
      fig.colorbar(imgplot, ax=ax1)
  #plt.xlabel('x [mm]')
  ax1.set_ylabel('y [mm]')
  #-----------------------------------------------------------------------------------
  vmin0 = round(fwhm0*(1.0-sf))
  vmax0 = round(fwhm0*(1.0+sf))
  if vmin0 < 0: vmin0 = 0
  
  ax2 = fig.add_subplot(332)
  #fwhm_m = ma.array(fwhm,mask=fwhm>1.0e8)
  imgplot = ax2.imshow(fwhm_m2, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #, picker=1) #vmin=fwhm.min(),vmax=fwhm.max())
  fig.colorbar(imgplot, ax=ax2)
  ax2.set_title('FWHM [$\mu$rad]',size=ftsize)
  #ax2.set_xlabel('x [mm]')
  ax2.set_ylabel('y [mm]')
  #-----------------------------------------------------------------------------------
  vmin0 = round(stdev0*(1.0-sf))
  vmax0 = round(stdev0*(1.0+sf))
  if vmin0 < 0: vmin0 = 0
    
  ax3 = fig.add_subplot(333)
  #stdev_m = ma.array(stdev,mask=stdev>1.0e8)
  imgplot = plt.imshow(stdev_m2, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=fwhm.min(),vmax=fwhm.max())
  plt.colorbar(imgplot, ax=ax3)
  ax3.set_title('STDEV [$\mu$rad]',size=ftsize)
  ax3.set_xlabel('x [mm]')
  ax3.set_ylabel('y [mm]')
  #grid(True)
  #-----------------------------------------------------------------------------------
  vmin0=round(com0-mf*fwhm0)
  vmax0=round(com0+mf*fwhm0)
  
  ax4 = fig.add_subplot(334)
  #com_m = ma.array(com,mask=com>1.0e8)
  imgplot = plt.imshow(com_m2, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=com.min(),vmax=com.max())
  plt.colorbar(imgplot, ax=ax4)
  ax4.set_title('COM [$\mu$rad]',size=ftsize)
  #plt.xlabel('x [mm]')
  ax4.set_ylabel('y [mm]')
  #-----------------------------------------------------------------------------------
  vmin0=round(thmid0-mf*fwhm0)
  vmax0=round(thmid0+mf*fwhm0)
  
  ax5 = fig.add_subplot(335)
  #thmid_m = ma.array(thmid,mask=thmid>1.0e8)
  imgplot = plt.imshow(thmid_m2, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=thmid.min(),vmax=thmid.max())
  plt.colorbar(imgplot, ax=ax5)
  ax5.set_title('Midpoint [$\mu$rad]',size=ftsize)
  #plt.xlabel('x [mm]')
  ax5.set_ylabel('y [mm]')
  
  #ax6 = fig.add_subplot(336)
  #ax6.axis('off')
  #-----------------------------------------------------------------------------------
  vmin0=round(thneg0-1.0*mf*fwhm0)
  vmax0=round(thmid0)
  
  ax7 = fig.add_subplot(337)
  #thneg_m = ma.array(thneg,mask=thneg>1.0e8)
  imgplot = plt.imshow(thneg_m2, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=thneg.min(),vmax=thneg.max())
  plt.colorbar(imgplot, ax=ax7)
  ax7.set_title('Left Slope [$\mu$rad]',size=ftsize)
  ax7.set_xlabel('x [mm]')
  ax7.set_ylabel('y [mm]')
  #-----------------------------------------------------------------------------------  
#  vmin0=round(com0-(sf-1.0)*fwhm0,-1)
  vmin0=round(thmid0)
  vmax0=round(thpos0+1.0*mf*fwhm0)
  
  ax8 = fig.add_subplot(338)
  #thpos_m = ma.array(thpos,mask=thpos>1.0e8)
  imgplot = plt.imshow(thpos_m2, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=thpos.min(),vmax=thpos.max())
  plt.colorbar(imgplot, ax=ax8)
  ax8.set_title('Right Slope [$\mu$rad]',size=ftsize)
  ax8.set_xlabel('x [mm]')
  ax8.set_ylabel('y [mm]')
  #-----------------------------------------------------------------------------------  
  #plt.subplot(333) 
  #axis('off')
  #plt.title('Crystal orientation')
  #plt.annotate('vertical', xy=(0.5,1.0), xytext=(0.5,0.0),
  #            arrowprops=dict(facecolor='black', shrink=0.05),
  #                        )
  #plt.annotate('horizontal', xy=(1.0,0.5), xytext=(0.0,0.5),
  #            arrowprops=dict(facecolor='black', shrink=0.05),
  ##                        )
  ax9 = fig.add_subplot(339)
  ax9.axis('off')
  ax9.text(0,-0.2,out,size=13)  
  #---------------------------------------------
  ############################################################
  # picker attempt:    
  ############################################################
  def onpick(event):
    if event.button == 3:
      xdata = event.xdata
      ydata = event.ydata
      #ind = event.ind
      xydata = (xdata, ydata) 
      print('--------------------------------------------------------------------------') 
      print('Local RC:')  
      print('onpick coordinates (X,Y): (%.3f, %.3f)' % xydata)
      idx = nx-int(ceil(xdata/dx)) - nnx1  # ceil works best, still needs further testing
      idy = ny-int(ceil(ydata/dy)) - nny1  # ceil works best, still needs further testing 
      print('onpick indicies (Ix,Iy):', (idx,idy))
      #----------------------------------------------
      # plot local rocking curve
      #----------------------------------------------
      mpl.rcParams.update({'font.size': 12})
      fig=plt.figure(figsize=(8.0,7.0))
      #rcurve00=data1[:,idy,idx]
      rcurve00=rcurve_0[:,idy,idx]
      #b00=0.25*(rcurve00[0]+rcurve00[1]+rcurve00[-2]+rcurve00[-1])
      #print('bkg (from tails) = %f' % b00)
      #if conduct == 1:
      #    rcurve00 = -1.0*(rcurve00 - b00)      
      #else: 
      #    rcurve00 = rcurve00 - b00
      # begin plotting:
      plt.title ('pixel location [mm]: X ='+str(round(xdata,3))+', Y = '+str(round(ydata,3)),size=16) 
      plt.plot(ugol,rcurve00,'b-')
      plt.plot(ugol,rcurve00,'bo',label='local RC')
      plt.plot(ugol,ugol*0, color='k', label='baseline (subtracted bkg)')
      # Generic FWHM
      try: 
        result=curvestat(ugol,rcurve00,0.0)
        th_max00=result[0]; r_max00=result[1]
        th_neg00=result[2]; th_pos00=result[3]; th_mid00=result[4]
        fwhm00=result[5]; com00=result[6]
        stdev00=sqrt(abs(result[7]))
        print('Generic FWHM/COM:')
        print('r_max [ct] =  %f' % r_max00)
        print('th_max [urad] = %f' % th_max00)
        print('th_mid [urad] = %f' % th_mid00)
        print('com [urad] = %f' % com00)
        print('stdev [urad] =  %f' % stdev00)
        print('fwhm [urad] = %f'   %fwhm00)
        # Gaussian fit
        p00=[r_max00,com00,sqrt(2.0)*(fwhm00/2.355)] #
        p_g, unc, dte, stat, cov = fit1d(residuals0g,p00,ugol,rcurve00) 
        stdev00 = abs(p_g[2])/sqrt(2.0)
        fwhm00 = 2.0*abs(p_g[2])*sqrt(log(2.0))      
        #
        print('Gaussian fit:')
        print('r_max_g [ct] =  %f' % p_g[0])
        print('th_max_g [urad] = %f' % p_g[1])
        print('stdev_g [urad] =  %f' % stdev00)
        print('fwhm_g [urad] = %f'   %fwhm00)
        # Lorentzian fit
        p00=[r_max00,com00,fwhm00/2.0] #
        p_l, unc, dte, stat, cov = fit1d(residuals0l,p00,ugol,rcurve00)
        fwhm00 = 2.0*abs(p_l[2])
        # com and stdev is infinity for Lorentzian
        print('Lorentzian fit:')
        print('r_max_l [ct] =  %f' % p_l[0])
        print('th_max_l [urad] = %f' % p_l[1])
        #print('stdev_l [urad] =  %f' % stdev00)
        print('fwhm_l [urad] = %f'   %fwhm00)        
        #print('--------------------------------------------------------------------------')    
        ugol_g=arange(ugol[0],ugol[-1]+0.1,0.1)
        plt.plot(ugol_g,gauss0(p_g,ugol_g),'b--',label="Gauss. fit") 
        plt.plot(ugol_g,lorentz0(p_l,ugol_g),'g--',label="Lorentz. fit")
        plt.plot(ugol,0.5*(r_max00)+ugol*0, linestyle='--', color='k', label='half max.')        
      except: 
        print('Curve statistics unobtainable')
      plt.xlabel('$\\theta - \\theta_0$, [$\mu$rad]', size=16)
      plt.ylabel('Counts', size=16)
      plt.legend(loc='upper left',fontsize=10)
      plt.show()
  #
  fig.canvas.mpl_connect('button_press_event', onpick)
#  plt.show()
  #####################################################################################
  # FIGURES FOR PUBLICATION/SAVE PROCESSED DATA
  ##################################################################################### v 0.05 update  
  # one and unique offset subtraction for all, let it be thmid0
  com_exp = array(com) - thmid0   #-com0 
  thmid_exp = array(thmid) - thmid0 #-thmid0 
  thneg_exp = array(thneg) - thmid0  #-thneg0
  thpos_exp = array(thpos) - thmid0  #-thpos0
  ############################################################################################################## 
  if opts.publish==1:
    user_dir = os.getcwd()
    sys.path.append(user_dir)
    from figures import figplot        
    figplot(trans,dx,dy,indx1,indx2,indy1,indy2,peak,fwhm,stdev,com_exp,thmid_exp,thneg_exp,thpos_exp)
    sys.path.pop()
  ############################################################################################################## 
  if opts.hdf5 is not None:
    hf = h5py.File(opts.hdf5, 'w')
    hf.attrs['cmd'] = param
    g1 = hf.create_group("/parameters")    
    g1.create_dataset('dx',data = dx)
    g1.create_dataset('dy',data = dy)
    g1.create_dataset('indx1',data = indx1)
    g1.create_dataset('indx2',data = indx2)
    g1.create_dataset('indy1',data = indy1)
    g1.create_dataset('indy2',data = indy2)
    #-------------------------------------------------------------------------------
    g2 = hf.create_group("/topographs")
    g2.create_dataset('peak',  data=array(peak),  shape=peak.shape,  dtype=float32)
    g2.create_dataset('fwhm',  data=array(fwhm),  shape=fwhm.shape,  dtype=float32)
    g2.create_dataset('stdev', data=array(stdev), shape=stdev.shape, dtype=float32)
    g2.create_dataset('com',   data=array(com),   shape=com.shape,   dtype=float32)
    g2.create_dataset('thmid', data=array(thmid), shape=thmid.shape, dtype=float32)
    g2.create_dataset('thneg', data=array(thneg), shape=thneg.shape, dtype=float32)
    g2.create_dataset('thpos', data=array(thpos), shape=thpos.shape, dtype=float32)
    #--------------------------------------------------------------------------------
    g3 = hf.create_group("/statistics")
    g3.create_dataset('peak0',     data=peak0)
    g3.create_dataset('peak_rms',  data=peak_rms)
    g3.create_dataset('peak_pv',   data=peak_pv)
    g3.create_dataset('fwhm0',     data=fwhm0)
    g3.create_dataset('fwhm_rms',  data=fwhm_rms)
    g3.create_dataset('fwhm_pv',   data=fwhm_pv)
    g3.create_dataset('stdev0',    data=stdev0)
    g3.create_dataset('stdev_rms', data=stdev_rms)
    g3.create_dataset('stdev_pv',  data=stdev_pv)
    g3.create_dataset('com0',      data=com0)
    g3.create_dataset('com_rms',   data=com_rms)
    g3.create_dataset('com_pv',    data=com_pv)
    g3.create_dataset('thmid0',    data=thmid0)
    g3.create_dataset('thmid_rms', data=thmid_rms)
    g3.create_dataset('thmid_pv',  data=thmid_pv)
    g3.create_dataset('thneg0',    data=thneg0)
    g3.create_dataset('thneg_rms', data=thneg_rms)
    g3.create_dataset('thneg_pv',  data=thneg_pv)
    g3.create_dataset('thpos0',    data=thpos0)
    g3.create_dataset('thpos_rms', data=thpos_rms)
    g3.create_dataset('thpos_pv',  data=thpos_pv)
    #---------------------------------------------------------------------------------
    g4 = hf.create_group("/statistics_tot")
    g4.create_dataset('peak_tot',  data=peak_tot)
    g4.create_dataset('fwhm_tot',  data=fwhm_tot)
    g4.create_dataset('stdev_tot', data=stdev_tot)
    g4.create_dataset('com_tot',  data=com_tot)
    g4.create_dataset('thmid_tot',  data=thmid_tot)
    g4.create_dataset('thneg_tot',  data=thneg_tot)
    g4.create_dataset('thpos_tot',  data=thpos_tot)
    #----------------------------------------------------------------------------------    
    hf.close()
  if opts.tif == 1:
    im = Image.fromarray(peak)
    im.save('peak.tif')
    im = Image.fromarray(fwhm)
    im.save('fwhm.tif')
    im = Image.fromarray(stdev)
    im.save('stdev.tif')
    im = Image.fromarray(com)
    im.save('com.tif')
    im = Image.fromarray(thmid)
    im.save('thmid.tif')
    im = Image.fromarray(thneg)
    im.save('thneg.tif')
    im = Image.fromarray(thpos)
    im.save('thpos.tif')    
######################################################################################## 
## PLOT SLICES AND WRITE FILE
########################################################################################
                 
  if xsl >= 0 or ysl >= 0:    
      
      f3=plt.figure(3,figsize=(22.0,12.2))         
      plt.suptitle(sbtitle0+sbtitle, size=20)  
      plt.subplot(331)
      #peak_sl_m=np.ma.array(peak_sl,mask=peak_sl>10.0*max(peak1))
      plt.plot(range_sl,peak_sl)
      plt.title('Reflectivity',size=ftsize)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(332)
      #fwhm_sl_m=np.ma.array(fwhm_sl,mask=fwhm_sl>100.0*fwhm0)
      plt.plot(range_sl,fwhm_sl)
      plt.title('FWHM [$\mu$rad]',size=ftsize)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(333)
      #stdev_sl_m=np.ma.array(stdev_sl,mask=stdev_sl>100.0*stdev0)
      plt.plot(range_sl,stdev_sl)
      plt.title('STDEV [$\mu$rad]',size=ftsize)
      plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')

      plt.subplot(334)
      #com_sl_m=np.ma.array(com_sl,mask=com_sl>1.0e6)
      plt.plot(range_sl,com_sl)
      plt.title('COM [$\mu$rad]',size=ftsize)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(335)
      #thmid_sl_m=np.ma.array(thmid_sl,mask=thmid_sl>1.0e6)
      plt.plot(range_sl,thmid_sl)
      plt.title('Midpoint [$\mu$rad]',size=ftsize)
      #plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')

      plt.subplot(337)
      #thneg_sl_m=np.ma.array(thneg_sl,mask=thneg_sl>1.0e6)
      plt.plot(range_sl,thneg_sl)
      plt.title('Left Slope [$\mu$rad]',size=ftsize)
      plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')

      plt.subplot(338)
      #thpos_sl_m=np.ma.array(thpos_sl,mask=thpos_sl>1.0e6)
      plt.plot(range_sl,thpos_sl)
      plt.title('Right Slope [$\mu$rad]',size=ftsize)
      plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')
      
  plt.show() 
  
  if opts.write is not None:
     header = '# '+ str(sys.argv) +'\n' \
            +'# version '+__version__+' by Stanislav Stoupin\n' \
            +'# Slices data\n' \
            +'# columns: \n' \
            '# '+str_axis+' peak(norm) FWHM[urad] COM[urad] mid-point[urad] left-slope[urad] right-slope[urad] STDEV[urad]\n'
     try:                
            writeFile(opts.write,header,range_sl,peak_sl,fwhm_sl,com_sl,thmid_sl,thneg_sl,thpos_sl,stdev_sl)
     except IOError as e:
            fatalIOError(e)                                        
                   
if __name__ == '__main__':
        freeze_support()
        main()                      
