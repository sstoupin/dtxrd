#!/usr/bin/env python

'''
a program to view data array in hdf files as an image

:author:    Stanislav Stoupin
:email:     sstoupin@aps.anl.gov

:copyright: Copyright 2014 by XSD, Advanced Photon Source, Argonne National Laboratory
:license:   UChicago Argonne, LLC Open Source License, see LICENSE for details.
'''
import sys
import os
from numpy import *
from pylab import *

#LOCAL
#from pyhdf import *

#GLOBAL
from dtxrd.pyhdf import *

prog = os.path.basename(sys.argv[0])
############################################################
__version__='0.13'
proginfo = prog + __version__ + ', by Stanislav Stoupin <sstoupin@aps.anl.gov>'
########################################################################################
# v 0.12 - after pyhdf modification and convention for image transformation is adopted
# v 0.13 - minor adaptation to run globally


def fatalError(msg):
        sys.stderr.write('Error: ')
        sys.stderr.write(str(msg))
        sys.stderr.write('\n')
        sys.exit(1)
                                
def fatalIOError(err):
        if issubclass(err.__class__, IOError) and err.strerror and err.filename:
                  err = '%s: %s' % (err.strerror, err.filename)
        fatalError(err)
                                                                
def ParseArguments(args):
        try:
                from optik import OptionParser
        except ImportError:
                try:
                       from optparse import OptionParser
                except ImportError:
                       fatalError(
'This program requires Optik, availible from http://optik.sourceforge.net/\n')

        USAGE = '%prog [OPTIONS...] filename1 filename2 ...'
        VERSION = '%prog ' + __version__ + ', by Stanislav Stoupin <sstoupin@aps.anl.gov>\n' 
        parser = OptionParser(usage=USAGE, version=VERSION)                        
        #
        # Behavior
        #
        parser.add_option('-o', '--output',
                action='store',
                dest='output',
                default=None,
                help='write results to file F (defaults to stdout)',
                metavar='F')
        parser.add_option('-p', '--publish',
                action='store_const',
                const=1,
                dest='publish', 
                default=0,  
                help='generate figures for publication')
        parser.add_option('-s', '--transpose',
                action='store_const',
                const=1,
                dest='transpose', 
                default=0,  
                help='transpose image matrix')                
        parser.add_option('-i', '--instrument',
                action='store_const',
                const=1,
                dest='instrument',
                default=0,
                help='read parameters from instrument file ccd.py')
        #                                                                              
        opts, args = parser.parse_args(args)
        if len(args) < 1:
                parser.print_usage()
                sys.exit(1)
        return opts, args                


def main(opts, args):
  if opts.output is not None:
     try:
        outFile = open(opts.output, 'w')
     except IOError, e:
        fatalIOError(e)
  else:
     outFile = sys.stdout

  if opts.instrument == 1:  # if instrument file ccd.py is used      
      # import parameters from ccd.py
      from ccd import rbin,dx,dy,tot_range,dyn_range,fwhm_0,bkg0
      from ccd import data_path,th_path,chi_path 
      from ccd import a2urad
  else:
      rbin=1
      dx, dy = 1.0, 1.0  # CCD camera pixel size [mm]
      tot_range=10000.0     # upper limit for threshold processing (to exclude "dead" pixels)
      dyn_range=10000.0      # upper limit for threshold processing (gauss)
      fwhm_0=30.0        # expected fwhm (for fitting)
      bkg0=2750.0        # "reasonable" background - dark current count
      # default paths in hdf or h5 file
      data_path='/entry/instrument/detector/data'
      th_path='/entry/instrument/detector/NDAttributes/theta'
      chi_path='/entry/instrument/detector/NDAttributes/chi'
  dx=float(rbin)*dx
  dy=float(rbin)*dy
#                                                    
  outFile.write('# seehdf '+__version__+' by Stanislav Stoupin <sstoupin@gmail.com>\n')
  count=1
  for fn in args:   
      fn_ext=fn.split(".")[-1]
      if fn_ext == "hdf":
          angle, size, im = read_hdf4(fn)
      elif fn_ext == "h5":
          angle, chi, size, im = read_hdf5(fn,rbin,data_path,th_path,chi_path)
      else:
          fatalError('Supported files are either hdf4 (extension .hdf) or hdf5 (extension h5)')
      #
      if opts.transpose == 0:
          im=transpose(im)
          im=fliplr(im)
          nx=size[1]
          ny=size[0]
      else:
          nx=size[0] #;print nx
          ny=size[1] #;print ny
          im=flipud(im)
                                                                        
          #im=fliplr(im)                                   
          #nx=size[0] #;print nx
          #ny=size[1] #;print ny    
      theta = a2urad*angle
      if opts.publish !=1:
          xyrange=(0,dx*nx,0,dy*ny)
          plt.figure()
          plt.imshow(im, extent=xyrange)  
          plt.colorbar()
          plt.title(fn)
          plt.xlabel('x [mm]')
          plt.ylabel('y [mm]') 
      else:
          from publish import figplot
          indx1=0; indx2=nx
          indy1=0; indy2=ny 
          print "opts.transpose", opts.transpose
          figplot(opts.transpose,dx,dy,indx1,indx2,indy1,indy2,im,fn,theta)
      count = count + 1              
      outFile.write('# filename: '+fn+'\n')
      outFile.write('# image: '+str(nx)+' x '+str(ny)+'\n')
      outFile.write('theta [urad] = '+str(theta)+'\n')
      outFile.write('chi [orig. u.] = '+str(chi)+'\n')
  outFile.close  
  plt.show()     
    
if __name__ == '__main__':
        options, args = ParseArguments(sys.argv[1:])
        main(options, args)                      
