#!/usr/bin/env python

'''
a program for sequential topography/rocking curve imaging

:author:    Stanislav Stoupin
:email:     sstoupin@aps.anl.gov

:copyright: Copyright 2014 by XSD, Advanced Photon Source, Argonne National Laboratory
:license:   UChicago Argonne, LLC Open Source License, see LICENSE for details.
'''


import os, sys
import numpy
import operator

# LOCAL
#from numpy import *
#from pyhdf import *
#from curvestat import *
#from fit1d import *
#from myio import *
#from roll_zeropad import roll_zeropad

# GLOBAL
from dtxrd.pyhdf import *
from dtxrd.curvestat import *
from dtxrd.fit1d import *
from dtxrd.myio import *
from dtxrd.roll_zeropad import roll_zeropad

#from __future__ import division
from matplotlib.patches import Patch
from pylab import *
#from publish import *
##################################################################
## fixed constants
##################################################################
r2d=180.0/pi
fwhm_l=0.5          # lower fract. limit to plot fwhm distrib
fwhm_r=1.5           # upper limit to plot fwhm distribution
##################################################################

__version__='0.77'
prog = os.path.basename(sys.argv[0])
proginfo = prog + __version__ + ', by Stanislav Stoupin <sstoupin@aps.anl.gov>'

#######################################################################################
# HISTORY
#######################################################################################
# 0. added gaussian fit for noisy data as an option "-g" v 0.2
# 1. need deglitching algorithm - done v 0.4
# 2. -b - custom background done v 0.4
# 3. calculate RMS and PV - done in v0.3
# 4. convenient output  done in v 0.3
# 5. a bug fixed with image orientation v 0.4 - for some reason the arrays have to be 
# transposed  v0.4
# 6. introduced colormap range factor (-f _value_  option)
# 7. statistics for selected rectangular region implemented   done v 0.6
# 9. need to sort data for every pixel based on angle values! done v 0.5
# 10. added upper limit on dyn_range (fixed value) 	      done v 0.51
# 11. added search for peak index to improve gaussian fit     done v 0.52
# 12. move dyn_range and other constants to the beginning
#	introduce df as an input parameter to the parser      done v 0.61
#	deglitch by default				      done v 0.63
# 	improve threshold upper limit processing	      done v 0.63
#       subtract bkg from peak data                           done v 0.63
#       add bkg0 - dark current 			      done v 0.64
# 13. improve glitch and background determination (4 points)  done v 0.65
# v 066  fliplr applied to flip left to right so that the images show up as the 
#        incident beam sees them
#        added sample name to report plot as an option
# v067   additional pixel rejection criteria based on the bkg level and on the 
#        COM and FWHM values (worked with Si 220 transmission data)
#        eventually best way to reject bad pixels - just treshold (e.g. -t 1.2)
# v068   added support for hdf5 files 
#        introduced instrument files ccd.py
# v069   minor iteration to adapt to data from topolab (Tim Madden's CCD)
# v070   added a capability to extract and plot slices
#        rearrangement of output files - now separate files for statistics and map data
# v071   fixed input for rotated matrixes 
#        now absence of transpose card processes images which correspond to as collected
#        data - the image is rotated in the data acquisition software so that the desired 
#        is obtained and this orientation is preserved with absence of transpose (-s) 
#        card in the processed rocking curve maps
# v072   added command line to the bottom of the main figure
# v073   switched rollzeropad to global import
# v074   disable writing map data with -o option 
#        -w option only makes sense when saving slices
# v075   when importing modules point to user_dir through os.getcdw()
#        append to path and when import is done exclude sys.path.pop()
# v076   introduced calculation for total rocking curve over the selected region 
#        output for prcurve(pixel) and trcurve(total/region) in the same file
# v077   improve logic on handling integrated reflectivity (now possible to integrate 
#        and normalize)
#######################################################################################
#  TODO LIST
#######################################################################################
# 0. need to improve comput. speed!
# 1. need mouse click access to each point on the maps
# 2. need total rocking curve
# 3. need to select region for processing
####################################################################################### 

def residuals(p,y,x):
        return y-gauss(p,x)

def fatalError(msg):
        sys.stderr.write('Error: ')
        sys.stderr.write(str(msg)) 
        sys.stderr.write('\n')
        sys.exit(1)

def fatalIOError(err):
        if issubclass(err.__class__, IOError) and err.strerror and err.filename:
                  err = '%s: %s' % (err.strerror, err.filename)
        fatalError(err)
                                                                
def ParseArguments(args):
        try:
                from optik import OptionParser
        except ImportError:
                try:
                       from optparse import OptionParser
                except ImportError:
                       fatalError(
'This program requires Optik, availible from http://optik.sourceforge.net/\n')

        USAGE = prog + ' [OPTIONS...] filename1 filename2 ... \n' \
        +'the program computes and displays rocking curve maps using a series of CCD \n' \
        +'images taken at different angles on the rocking curve of a crystal\n' \
        +'for options type: rctopo -h \n' \
        +'Cheers!'
        VERSION = '%prog ' + __version__ + ', by Stanislav Stoupin <sstoupin@aps.anl.gov>\n' 
        parser = OptionParser(usage=USAGE, version=VERSION)                        
        #
        # Behavior
        #
        
        #Output
        parser.add_option('-o', '--output',
                action='store',
                dest='output',
                default=None,
                help='write calculated parameters to file F (defaults to stdout); also, write output for 1pix_total.dat',
                metavar='F')
        parser.add_option('-w', '--write',
                action='store',
                dest='write',
                default=None,
                help='write data to file D (default: do not write) - reserved for slice data',
                metavar='D')        
        parser.add_option('-t', '--threshold',
                action='store',
                dest='tr',
                default=1.05,
                help='processing threshold in reflectivity to define the crystal boundaries',
                metavar='CONST')
        parser.add_option('-b', '--background',
                action='store',
                dest='bkg',
                default=-1,
                help='background from CCD',
                metavar='CONST')
                #
        parser.add_option('-a', '--ashift',
                action='store',
                dest='ashift',
                default=0,
                help='compensate beam shift in the imaging plane at a distance CONST [m]',
                metavar='CONST')
                #
        parser.add_option('-r', '--range',
                action='store',
                dest='rng',
                default='-1 -1 -1 -1',
                help='map range for analysis',
                metavar='STRING')
        parser.add_option('-x', '--xslice',
                action='store',
                dest='xsl',
                default=-1,
                help='slice and plot distribution at a fixed coordinate X',
                metavar='CONST')
        parser.add_option('-y', '--yslice',
                action='store',
                dest='ysl',
                default=-1,
                help='slice and plot distribution at a fixed coordinate Y',
                metavar='CONST')
        parser.add_option('-n', '--name',
                action='store',
                dest='nm',
                default='',
                help='sample name',
                metavar='STRING')                
        parser.add_option('-f', '--factor',
                action='store',
                dest='f',
                default=1.0,
                help='factor*fwhm_aver defines range of colormap on peak/slope position images',
                metavar='CONST')  
        parser.add_option('-m', '--magnify',
                action='store',
                dest='m',
                default=1.0,
                help='shirks colormap range for fwhm by this factor',
                metavar='CONST')  
        parser.add_option('-d', '--deglitch',
                action='store',
                dest='degl',
                default=-1.0,
                help='deglitch data',
                metavar='CONST')
        parser.add_option('-g', '--gaussian',
                action='store_const',
                const=1,
                dest='stat',
                default=0,
                help='do gaussian curve fitting - for noisy data')
        parser.add_option('-s', '--trasnpose',
                action='store_const',
                const=1,
                dest='transpose',
                default=0,
                help='transpose images for plotting')
        parser.add_option('-u', '--units',
                action='store',
                dest='units',
                default='deg',
                help='angular units: deg, arcsec, urad',
                metavar='STRING')
        parser.add_option('-p', '--publish',
                action='store_const',
                const=1,
                dest='publish',
                default=0,
                help='generate figures for publication')
        parser.add_option('-i', '--instrument',
                action='store_const',
                const=1,
                dest='instrument',
                default=0,
                help='read parameters from instrument file ccd.py')                                                                       
        parser.add_option('-z', '--integrate',
                action='store',
                dest='z',
                default=0,
                help='integrate reflectivity and normalize by theoretical angular acceptance for perfect crystal (input value) \n' 
                + 'hint: z == 0 - do not integrate (default), z != 0 - integrate , z ==-1 - integrate and normalize by max. value',
                metavar='CONST')                  
        #Parameters
        
        opts, args = parser.parse_args(args)
        if len(args) < 1:
                parser.print_usage()
                sys.exit(1)
        return opts, args                
###############################################################################                                
                                
def main(opts, args):
  if opts.output is not None:
     try:
        outFile = open(opts.output, 'w')
     except IOError, e:
        fatalIOError(e)
  else:
     outFile = sys.stdout
  
  nall = len(sys.argv)-len(args)
  param = sys.argv[0:nall]
  param = ' '.join(param)  
  outFile.write(param + '\n')                    
  #outFile.write(str(opts)+' '+str(args)+'\n')
  outFile.write(prog + ' v '+__version__+'\n')
  outFile.write('range (x1 x2 y1 y2): '+opts.rng+'\n')
  
#----------------------------------------------------- 
# initialize & set constants      
#-----------------------------------------------------
  alldata=[]
  data=[]
  th_deg=[]
  tr=float(opts.tr);   print "Threshold (tr) = ", tr
  df=float(opts.degl); print "Deglitching factor (df) = ", df
  sf=float(opts.f);    print "Limit scale factor for plotting (sf) = ", sf
  mf=float(opts.m);    print "Shrink FWHM colormap range", mf
  nf=len(args);	       print "Number of files to analyze = ", nf
  zf=int(opts.z);      print "integrate reflectivity (==0 no, !=0 yes, ==-1 normalize", zf
  if opts.instrument == 1:  # if instrument file ccd.py is used
    user_dir = os.getcwd()
    sys.path.append(user_dir)
    from ccd import rbin,dx,dy,tot_range,dyn_range,fwhm_0,bkg0,data_path,th_path,chi_path   # import parameters from ccd.py  
    sys.path.pop()
  else:
    rbin=1
    dx, dy = 1.0, 1.0  # CCD camera pixel size [mm]    
    tot_range=10000.0     # upper limit for threshold processing (to exclude "dead" pixels)
    dyn_range=10000.0      # upper limit for threshold processing (gauss)
    fwhm_0=30.0        # expected fwhm (for fitting) 
    bkg0=2750.0        # "reasonable" background - dark current count       
    # default paths in hdf or h5 file    
    data_path='/entry/instrument/detector/data'
    th_path='/entry/instrument/detector/NDAttributes/theta'
    chi_path='/entry/instrument/detector/NDAttributes/chi'
  dx=float(rbin)*dx
  dy=float(rbin)*dy
#---------------------------------------------------------------------------------------------  
  for fn in args:   
    fn_ext=fn.split(".")[-1]
    if fn_ext == "hdf":
      angle, size, im = read_hdf4(fn)
    elif fn_ext == "h5":
      angle, chi, size, im = read_hdf5(fn,rbin,data_path,th_path,chi_path)        
    else:
      fatalError('Supported files are either hdf4 (extension .hdf) or hdf5 (extension h5)')  
#   
    if opts.transpose == 0:
        im=transpose(im)
        im=fliplr(im)
        nx=size[1]
        ny=size[0]
    else:             
        nx=size[0] #;print nx
        ny=size[1] #;print ny            
        im=flipud(im)
#  print im.dtype
    print "filename: ", fn
    print "theta = ", angle
    print "chi = ", chi        
### sorting data by angle #######################
    data_fn=[angle,im]
    alldata=alldata+[data_fn]
    #
  alldata=sorted(alldata,key=operator.itemgetter(0))
#################################################    
  
  for x in alldata:
    th_deg=th_deg+[x[0]]            

  if opts.units=='deg':
    th=1.0e6*array(th_deg)/r2d # th_deg in degrees
  elif opts.units=='arcsec':
    th=1.0e6*array(th_deg)/(60.0)**2.0/r2d     #th_deg in arcseconds
  elif opts.units=='urad':
    th=array(th_deg)                           # th_deg in urad
  elif opts.units=='um':
    th=5.86*array(th_deg)                      # th_deg in microns
  elif opts.units=='volt':
    th=22.1388*array(th_deg)                      # th_deg in microns

################################################################################
## theta origin is defined here as the center of the angular range in the scan 
################################################################################
  th_beg=th[0]
  th_end=th[len(th)-1]
#  th0=0.5*(th[0]+th[len(th)-1])
  th0=0.5*(th_beg+th_end)  
  th0_deg=1.0e-6*r2d*th0
  
  print "###########################################"
  print "th0 (initial) = ", th0

  if opts.ashift == 0:
     for x in alldata:
         data=data+[x[1]]
  else:
     from ccd import th0
     #from roll_zeropad import roll_zeropad
     for (t,x) in map(None,th,alldata): 
        imdist = float(opts.ashift) # [m]
        imsh = 1.0e-6*(t-th0)*imdist*1.0e3 # image shift [mm]
        print "applied shifts [mm] =  ", imsh
        print "th0 [urad] = ", th0
        rind = int(imsh/dy); print "rind = ", rind 
        #sarray = roll(x[1],-rind,axis=0)
        sarray = roll_zeropad(x[1],-rind,axis=0)        
        data = data +[sarray]                                                 
  data=array(data); #print data
    
####################################################
## Analyzed Area (Range)
####################################################
  step=1
  #    
  rangexy=opts.rng.split(' ')    
  rngx1=float(rangexy[0]); rngy1=float(rangexy[2])
  rngx2=float(rangexy[1]); rngy2=float(rangexy[3])
  
  if rngx1<0:
    indx1=0
  else:
    indx1=int(rngx1/dx)
  if rngy1<0:
    indy1=0
  else:
    indy1=int(rngy1/dy)
#---------------------------------------  
  if rngx2<0 or rngx2>nx*dx:
    indx2=nx
  else:  
    indx2=int(rngx2/dx)
  if rngy2<0 or rngy2>ny*dy:
    indy2=ny
  else:
    indy2=int(rngy2/dy)        
  
  xrange=arange(nx-indx2,nx-indx1,step)
  yrange=arange(ny-indy2,ny-indy1,step) #;print yrange
#-----------------------------------------------------
#initialize arrays
#-----------------------------------------------------
  peak=numpy.empty((nx,ny))  #1
  fwhm=numpy.empty((nx,ny))  #2
  thmid=numpy.empty((nx,ny)) #3
  com=numpy.empty((nx,ny))   #4
  thneg=numpy.empty((nx,ny)) #5
  thpos=numpy.empty((nx,ny)) #6
  stdev=numpy.empty((nx,ny)) #7
  fwhm1=[]; peak1=[]; thmid1=[]; com1=[]; thpos1=[]; thneg1=[]; stdev1=[] # arrays to calclulate rms and pv
  rcurve_tot = [] # initialize total rcurve list
#-------------------------------------------------------  
  if opts.bkg > 0:
    bkg=float(opts.bkg)
    print "bkg is assigned through option, bkg = ", bkg
  else:
    print "bkg approximated by the endpoints"  
#-------------------------------------------------------  
  abs_max=data.max(); print 'abs_max = ', abs_max
#-------------------------------------------------------  
# Main stuff
#-------------------------------------------------------
  for j in yrange:
    for i in xrange:
      rcurve=data[:,j,i]
      #-------------------------------------------------
      # Background determination
      #-------------------------------------------------
      if opts.bkg==-1:    
        bkg=0.25*(rcurve[0]+rcurve[1]+rcurve[len(rcurve)-2]+rcurve[len(rcurve)-1]) #; print 'bkg = ', bkg  
      #------------------------------------------------
      # Deglitching procedure
      #------------------------------------------------                  
      if df>1.0:
        index=range(len(rcurve))
        index=index[2:len(rcurve)-2]
        for k in index:
          y=rcurve[k]
          mean=0.25*(rcurve[k-2]+rcurve[k-1]+rcurve[k+1]+rcurve[k+2])
          if y > df*mean or y < (2.0-df)*mean:
            rcurve[k]=mean
            print "X= ", dx*i, "Y= ",dy*j, " glitch found"   
      #---------------------------------------------------------------------------------------
      # add rcurve to rcurve_tot - afer deglitching if it is activated
      # subtracting bkg since it can vary from pixel to pixel
      rcurve_tot = rcurve_tot + [rcurve-bkg]                                    
      #--------------------------------------------------------------------------------------- 
      rcmax=max(rcurve)
      rmax=rcmax-bkg		       #; print 'rmax= ', rmax
      #---------------------------------------------------------------------------------------
#     tot=sum(rcurve)/len(rcurve)      #; print 'tot = ', tot
      rcurve_l=list(rcurve)
      max_i=rcurve_l.index(rcmax)
      thi0=th[max_i]-th0
      #---------------------------------------------------------      
      # define central pixel                                     
      indx0=int(0.5*(xrange[0]+xrange[len(xrange)-1]))
      indy0=int(0.5*(yrange[0]+yrange[len(yrange)-1]))
      #--------------------------------------------------------
      if (i==indx0) and (j==indy0):
            print "thi0 = ", thi0
            ugol=th-th0 #th_deg    
            p0=[bkg,rcmax,thi0,fwhm_0] #bkg max center std
            p, unc, dte, stat, cov = fit1d(residuals,p0,ugol,rcurve) 
            com0=sum((rcurve-p[0])*(ugol))/sum(rcurve-p[0]); print "com = ", com0
            print '--------------------------------------------------------------------------'
            print 'Gaussian fit at the central pixel'
            print 'X0 [mm] = ', float(xrange[0] + indx0)*dx
            print 'Y0 [mm] = ', float(yrange[0] + indy0)*dy
            print 'bkg = ', bkg
            print 'p = ', p
            print "FWHM =", 2.0*abs(p[3])*sqrt(log(2)), " urad"
            #--------------------------------------------------
            # assign rcurve from pixel for output
            # subtract background 
            prcurve = rcurve - bkg               
            ##################################################################################              
            # start plotting things ----------------------------------
            f1=plt.figure()
            plt.plot(ugol,prcurve, 'bo',label="pixel RC") 
            plt.plot(ugol,prcurve, 'b-')
            ugol_g=arange(ugol[0],ugol[len(ugol)-1]+0.1,0.1)
            plt.plot(ugol_g,gauss(p,ugol_g)-p[0],'b--',label="Gaussian/pixel RC")            
            plt.title ('pixel location [mm]: X ='+str((nx-i)*dx)+', Y = '+str((ny-j)*dy))  
            plt.xlabel('$\\theta - \\theta_0$, [$\mu$rad]', size='x-large')
            plt.ylabel('Counts [a.u.]', size='x-large')
            ax = plt.gca()
            fontsize=12
            for tick in ax.xaxis.get_major_ticks():
                tick.label1.set_fontsize(fontsize)
            for tick in ax.yaxis.get_major_ticks():
                tick.label1.set_fontsize(fontsize)
                            
################################################################################################################## 
####### PIXEL REJECTION CRITERIA ################################################################################# 
##################################################################################################################  
      if bkg<dyn_range*bkg0 and rcmax>tr*bkg and rcmax<tot_range*bkg0:  
                    
          if opts.stat==1:
                p0=[bkg,rcmax,thi0,fwhm_0]
                p, unc, dte, stat, cov = fit1d(residuals,p0,th-th0,rcurve)                                
                if abs(p[0]) < dyn_range*bkg0 and abs(p[2]) < 0.5*abs(th_end-th_beg) and abs(p[3]) < abs(th_end-th_beg):  # and cov !='NA' # as an option
                  #
                  fwhm_g=2.0*abs(p[3])*sqrt(log(2.0))
                  fwhm[i,j]=fwhm_g;      fwhm1=fwhm1+[fwhm[i,j]]
                  peak[i,j]=p[1];        peak1=peak1+[peak[i,j]]   # p[1] - in gauss function background already subtracted               
                  thmid[i,j]=p[2];       thmid1=thmid1+[thmid[i,j]]
                  #com[i,j]=sum((rcurve-p[0])*(th-th0))/sum(rcurve-p[0]); com1=com1+[com[i,j]]                                    
                  com[i,j]=p[2];         com1=com1+[com[i,j]]               
                  stdev[i,j]=abs(p[3])/sqrt(2.0); stdev1=stdev1+[stdev[i,j]]
                  thneg[i,j]=p[2]-fwhm_g/2.0; thneg1=thneg1+[thneg[i,j]]
                  thpos[i,j]=p[2]+fwhm_g/2.0; thpos1=thpos1+[thpos[i,j]]
                else:
                  fwhm[i,j]=1e9
                  peak[i,j]=1e9
                  thmid[i,j]=1e9
                  com[i,j]=1e9
                  thneg[i,j]=1e9
                  thpos[i,j]=1e9  
                  stdev[i,j]=1e9
          else:
              try: 
                stat=curvestat(th-th0,rcurve,bkg)
                if abs(stat[1]-bkg) < dyn_range*bkg and abs(stat[6]) < 0.5*abs(th_end-th_beg) and abs(stat[5]) < abs(th_end-th_beg):
                  fwhm[i,j]=stat[5];         fwhm1=fwhm1+[fwhm[i,j]]
                  
                  if opts.z == 0:
                      peak[i,j]=stat[1]-bkg
                  else:
                      peak[i,j]=stat[8]/abs(zf)
                      #                                            
                  peak1=peak1+[peak[i,j]]    # peak intensity - bkg
                  thmid[i,j]=stat[4];        thmid1=thmid1+[thmid[i,j]]
                  com[i,j]=stat[6];          com1=com1+[com[i,j]]
                  stdev[i,j]=sqrt(abs(stat[7]));  stdev1=stdev1+[stdev[i,j]]  # variance to standard deviation
                  thneg[i,j]=stat[2];        thneg1=thneg1+[thneg[i,j]]
                  thpos[i,j]=stat[3];        thpos1=thpos1+[thpos[i,j]]
                else:
                  fwhm[i,j]=1e9
                  peak[i,j]=1e9
                  thmid[i,j]=1e9
                  com[i,j]=1e9
                  thneg[i,j]=1e9
                  thpos[i,j]=1e9
                  stdev[i,j]=1e9                                                            
####################################################################
## Testing
####################################################################
#                if com[i,j] > 0:
#                  print "flag!", i, j
                  #com[i,j]=-1e3                  
#                if (i==xi) and (j==yi):
#                    print "fwhm check", fwhm[i,j]
#                    print "com check", com[i,j]
####################################################################            

              except UnboundLocalError:
                fwhm[i,j]=1e9
                peak[i,j]=1e9
                thmid[i,j]=1e9
                com[i,j]=1e9
                thneg[i,j]=1e9
                thpos[i,j]=1e9
                stdev[i,j]=1e9
          
      else:  
        fwhm[i,j]=1e9
        peak[i,j]=1e9
        thmid[i,j]=1e9
        com[i,j]=1e9
        thneg[i,j]=1e9
        thpos[i,j]=1e9
        stdev[i,j]=1e9
                
#  norm=peak.max() 
#  print "blah"
#  print peak1
  norm=max(peak1)
  if zf == 0 or zf == -1:
      peak=peak/norm
      peak1=peak1/norm        
  
  fwhm1=array(fwhm1)
  stdev1=array(stdev1)
  peak1=array(peak1)
  thmid1=array(thmid1)
  com1=array(com1)  
  thneg1=array(thneg1)
  thpos1=array(thpos1)
  
  out='------------------------------------------------------------------------\n'
  #----------------------------------------------------------------------------------
  fwhm0=average(fwhm1);          out = out + "FWHM_average = "+str(fwhm0)+" urad\n"
  fwhm_rms=std(fwhm1);           out = out + "FWHM_rms = "+str(fwhm_rms)+" urad\n"
  fwhm_pv=max(fwhm1)-min(fwhm1); out = out + "FWHM_pv = "+str(fwhm_pv)+" urad\n"
  #----------------------------------------------------------------------------------
  stdev0=average(stdev1);           out = out + "STDEV_average = "+str(stdev0)+" urad\n"
  stdev_rms=std(stdev1);            out = out + "STDEV_rms = "+str(stdev_rms)+" urad\n"
  stdev_pv=max(stdev1)-min(stdev1); out = out + "STDEV_pv = "+str(stdev_pv)+" urad\n"
  #----------------------------------------------------------------------------------
  peak0=average(peak1);          out = out + "Reflect_average = "+str(peak0)+"\n"
  peak_rms=std(peak1);           out = out + "Reflect_rms = "+str(peak_rms)+"\n"
  peak_pv=max(peak1)-min(peak1); out = out + "reflect_pv = "+str(peak_pv)+"\n"
  #----------------------------------------------------------------------------------
  com0=average(com1);         out = out + "COM_average = "+str(com0)+" urad\n"
  com_rms=std(com1);          out = out + "COM_rms = "+str(com_rms)+" urad\n"
  com_pv=max(com1)-min(com1); out = out + "COM_pv = "+str(com_pv)+" urad\n"
  #----------------------------------------------------------------------------------
  thmid0=average(thmid1);           out = out + "thmid_average ="+str(thmid0)+" urad\n"
  thmid_rms=std(thmid1);            out = out + "thmid_rms = "+str(thmid_rms)+" urad\n"
  thmid_pv=max(thmid1)-min(thmid1); out = out + "thmid_pv = "+str(thmid_pv)+" urad\n"
  #----------------------------------------------------------------------------------
  thneg0=average(thneg1);           out = out +"thneg_average = "+str(thneg0)+" urad\n"
  thneg_rms=std(thneg1);            out = out + "thneg_rms = "+str(thneg_rms)+" urad\n"
  thneg_pv=max(thneg1)-min(thneg1); out = out + "thneg_pv = "+str(thneg_pv)+" urad\n"
  #----------------------------------------------------------------------------------
  thpos0=average(thpos1);           out = out + "thpos_average = "+str(thpos0)+" urad\n"
  thpos_rms=std(thpos1);            out = out + "thpos_rms = "+str(thpos_rms)+" urad\n"
  thpos_pv=max(thpos1)-min(thpos1); out = out + "thpos_pv = "+str(thpos_pv)+" urad\n"
  out = out + '------------------------------------------------------------------------\n'
  #----------------------------------------------------------------------------------

##############################################################################
## Total rocking curve
##############################################################################
  rcurve_tot = array(rcurve_tot)
  trcurve =  sum(rcurve_tot,axis=0)/len(rcurve_tot)
  # Stats:
  bkg_tot=0.25*(trcurve[0]+trcurve[1]+trcurve[len(trcurve)-2]+trcurve[len(trcurve)-1]) ; print 'bkg_tot = ', bkg_tot
  stat=curvestat(th-th0,trcurve,bkg_tot)
  #
  fwhm_tot=stat[5];                 out = out + "fwhm_tot = "+str(fwhm_tot)+" urad\n"
  #
  if opts.z == 0:
      peak_tot=stat[1]-bkg_tot
  else:
      peak_tot=stat[8]/zf           
  out = out + "peak_tot = "+str(peak_tot)+"\n"
  #                                            
  thmid_tot=stat[4];                out = out + "thmid_tot = "+str(thmid_tot)+" urad\n"   
  com_tot=stat[6];                  out = out + "com_tot = "+str(com_tot)+" urad\n"
  stdev_tot=sqrt(abs(stat[7]));     out = out + "stdev_tot = "+str(stdev_tot)+" urad\n"
  thneg_tot=stat[2];                out = out + "thneg_tot = "+str(thneg_tot)+" urad\n"  
  thpos_tot=stat[3];                out = out + "thpos_tot = "+str(thpos_tot)+" urad\n"       
  plt.plot(ugol,trcurve, 'ro',label="total RC")
  plt.plot(ugol,trcurve, 'r-')
  plt.legend(loc='upper right')
##################################################################################
## Write output									
##################################################################################
  outFile.write('------------------------------------------------------------------------\n')
  outFile.write('peak max = '+str(norm)+'\n')
  outFile.write('threshold = '+str(tr)+'\n')        
  outFile.write('-----------------Statistics---------------------------------------------\n')
  outFile.write(out)
  
  #if opts.output is not None:
  #   outFile.write('-----------------Map of the selected range------------------------------------------\n')
  #
  #   for j in yrange:
  #     for i in xrange:
  #        outFile.write(str(i*dx)+' '+str(j*dy)+' '+str(peak[i,j])+' '+str(fwhm[i,j])+' ' \
  #        +str(com[i,j])+' '+str(thmid[i,j])+' '+str(thneg[i,j])+' '+str(thpos[i,j])+'\n')
  
  outFile.close
    
  if opts.output is not None:
      header="# RC from the selected pixel and total rocking curve over selected region \n# columns: ugol prcurve trcurve\n"
      writeFile("prcurve.dat", header, ugol, prcurve)                                                   
      header="# RC total rocking curve over selected region \n# columns: ugol trcurve\n"
      writeFile("trcurve.dat", header, ugol, trcurve)                                                   
##################################################################################  
##  Plot results
##################################################################################
  # need to "mirror" y indexes because in an array numbering starts from top left corner
  # affects only choice of range - does not affect plotting 
  # same for x since it was found that the image has to be reversed in x direction
  # note that for x fliplr is applied later while for y imshow origin='upper'

  # do stuff to display right
#  fwhm=flipud(fwhm)
#  peak=flipud(peak)
#  thmid=flipud(thmid)
#  com=flipud(com)
#  thneg=flipud(thneg)
#  thpos=flipud(thpos) 

#  fwhm=fliplr(fwhm)
#  peak=fliplr(peak)
#  thmid=fliplr(thmid)
#  com=fliplr(com)
#  thneg=fliplr(thneg)
#  thpos=fliplr(thpos) 

#      nnx1=indx1; nnx2=indx2
#      nny1=indy1; nny2=indy2
  nnx1=nx-indx2; nnx2=nx-indx1
  nny1=ny-indy2; nny2=ny-indy1
                
  fwhm=fwhm[nnx1:nnx2,nny1:nny2]
  stdev=stdev[nnx1:nnx2,nny1:nny2]
  peak=peak[nnx1:nnx2,nny1:nny2]
  thmid=thmid[nnx1:nnx2,nny1:nny2]
  com=com[nnx1:nnx2,nny1:nny2]
  thneg=thneg[nnx1:nnx2,nny1:nny2]
  thpos=thpos[nnx1:nnx2,nny1:nny2]  

#######################################################
## Extract slices
#######################################################  
  xsl=float(opts.xsl)
  ysl=float(opts.ysl)
  if xsl >= 0:
      indxsl = nx-int(xsl/dx) - nnx1
      #      
      peak_sl = peak[indxsl,:]
      fwhm_sl = fwhm[indxsl,:]
      stdev_sl = stdev[indxsl,:]
      com_sl = com[indxsl,:]
      thmid_sl = thmid[indxsl,:]
      thneg_sl = thneg[indxsl,:]
      thpos_sl = thpos[indxsl,:] 
      range_sl = dy*arange(indy1,indy2)
      sbtitle0 = 'Slices at X = '+str(xsl)+' '
      str_axis='y [mm]'
  #----------------------------------    
  if ysl >= 0:
      indysl = ny-int(ysl/dx) - nny1
      #
      peak_sl = peak[:,indysl]
      fwhm_sl = fwhm[:,indysl]
      stdev_sl = stdev[:,indysl]
      com_sl = com[:,indysl]
      thmid_sl = thmid[:,indysl]
      thneg_sl = thneg[:,indysl]
      thpos_sl = thpos[:,indysl]
      range_sl = dx*arange(indx1,indx2)
      sbtitle0 = 'Slices at Y = '+str(ysl)+' '      
      str_axis='x [mm]'
  #
  fwhm=transpose(fwhm)
  stdev=transpose(stdev)
  peak=transpose(peak)
  thmid=transpose(thmid)
  com=transpose(com)
  thneg=transpose(thneg)
  thpos=transpose(thpos)
  
  peak=fliplr(peak)
  fwhm=fliplr(fwhm)
  stdev=fliplr(stdev)  
  thmid=fliplr(thmid) 
  com=fliplr(com) 
  thneg=fliplr(thneg)
  thpos=fliplr(thpos)
  xyrange=(dx*indx1,dx*indx2,dy*indy1,dy*indy2)  # for some reason the arrays should be transposed   
  #
  #      
  if ysl >=0 or xsl >=0: 
      peak_sl=peak_sl[::-1]
      fwhm_sl=fwhm_sl[::-1]
      stdev_sl=stdev_sl[::-1]
      thmid_sl=thmid_sl[::-1]
      com_sl=com_sl[::-1]
      thneg_sl=thneg_sl[::-1]
      thpos_sl=thpos_sl[::-1] 
###################################################################################
## NOW PLOT EVERYTHING
###################################################################################
  
  f2=plt.figure(2)
  if opts.stat==1:
    sbtitle='Gaussian curve fit.'
  else:
    sbtitle='No fitting.'
    
  sbtitle='Rocking curve topographs: '+sbtitle
        
  if opts.nm != '':
    sbtitle=sbtitle+' Sample: '+opts.nm  #+'\n' + param  
  plt.suptitle(sbtitle, size=20)  
  
  gca().set_position((.1, .1, .1, .1))
  figtext(0.1,0.025,param)
  
  plt.subplot(331)
  #plt.imshow(peak, aspect='auto', extent=xyrange,vmin=0,vmax=1.0)
  #plt.colorbar()  
  if zf == 0:
      plt.imshow(peak, aspect='auto', extent=xyrange,vmin=0,vmax=1.0)
      plt.title('peak reflectivity [n.u.]',size=20)
      plt.colorbar()
  elif zf == -1:
     plt.imshow(peak, aspect='auto', extent=xyrange,vmin=0,vmax=1.0)
     plt.title('integrated refl. [n.u.]',size=20)
     plt.colorbar()      
  else: 
      vmin0=min(peak1)/1.0e6; vmax0=max(peak1)/1.0e6
      plt.imshow(peak/1.0e6, aspect='auto', extent=xyrange,vmin=vmin0,vmax=vmax0)
      plt.title('integrated refl. [cnt x urad x 10$^6$]',size=20)
      plt.colorbar()
  #plt.xlabel('x [mm]')
  plt.ylabel('y [mm]')

#  vmin0=round(fwhm_l*fwhm0,-1)
#  vmax0=round(fwhm_r*fwhm0,-1)
  vmin0=round(fwhm0*(1.0-mf*sf))
  vmax0=round(fwhm0*(1.0+mf*sf))
  if vmin0 < 0: vmin0 = 0
  
  plt.subplot(332)
  plt.imshow(fwhm, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=fwhm.min(),vmax=fwhm.max())
  plt.colorbar()
  plt.title('FWHM [urad]',size=20)
  #plt.xlabel('x [mm]')
  plt.ylabel('y [mm]')
  #grid(True)

  vmin0=round(stdev0*(1.0-mf*sf))
  vmax0=round(stdev0*(1.0+mf*sf))
  if vmin0 < 0: vmin0 = 0
    
  plt.subplot(333)
  plt.imshow(stdev, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=fwhm.min(),vmax=fwhm.max())
  plt.colorbar()
  plt.title('STDEV [urad]',size=20)
  plt.xlabel('x [mm]')
  plt.ylabel('y [mm]')
  #grid(True)

  vmin0=round(com0-sf*fwhm0)
  vmax0=round(com0+sf*fwhm0)
  
  plt.subplot(334)
  plt.imshow(com, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=com.min(),vmax=com.max())
  plt.colorbar()
  plt.title('COM (angle) [urad]',size=20)
  #plt.xlabel('x [mm]')
  plt.ylabel('y [mm]')

  vmin0=round(thmid0-sf*fwhm0)
  vmax0=round(thmid0+sf*fwhm0)
  
  plt.subplot(335)
  plt.imshow(thmid, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=thmid.min(),vmax=thmid.max())
  plt.colorbar()
  plt.title('mid-point (angle) [urad]',size=20)
  #plt.xlabel('x [mm]')
  plt.ylabel('y [mm]')

  vmin0=round(thneg0-1.0*sf*fwhm0)
  vmax0=round(thmid0)
  
  plt.subplot(337)
  plt.imshow(thneg, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=thneg.min(),vmax=thneg.max())
  plt.colorbar()
  plt.title('left slope (angle) [urad]',size=20)
  plt.xlabel('x [mm]')
  plt.ylabel('y [mm]')
  
#  vmin0=round(com0-(sf-1.0)*fwhm0,-1)
  vmin0=round(thmid0)
  vmax0=round(thpos0+1.0*sf*fwhm0)
  
  plt.subplot(338)
  plt.imshow(thpos, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=thpos.min(),vmax=thpos.max())
  plt.colorbar()
  plt.title('right slope (angle) [urad]',size=20)
  plt.xlabel('x [mm]')
  plt.ylabel('y [mm]')

  #plt.subplot(333) 
  #axis('off')
  #plt.title('Crystal orientation')
  #plt.annotate('vertical', xy=(0.5,1.0), xytext=(0.5,0.0),
  #            arrowprops=dict(facecolor='black', shrink=0.05),
  #                        )
  #plt.annotate('horizontal', xy=(1.0,0.5), xytext=(0.0,0.5),
  #            arrowprops=dict(facecolor='black', shrink=0.05),
  #                        )
  plt.subplot(339)
  axis('off')
  plt.text(0,0,out,size=13)  
#  plt.show()
  ################################
  # output for GLE
  ################################
#  thc=59.84
#  dx1=dx/sin(thc/r2d)
  if opts.output is not None:
    com_exp=array(com) #-com0    
    #        
    outfile1 = open('com.dat', 'w') 
    outfile2 = open('fwhm.dat', 'w')
    outfile3 = open('com1.dat', 'w')
    scom=shape(com_exp) #print "scom =", scom
#    sfwhm=shape(fwhm)    
    for i in range(0,scom[0],1):
      for j in range(0,scom[1],1):
        outfile1.write(str(i*dx)+' '+str(j*dy)+' '+str(com_exp[i,scom[1]-1-j])+'\n')  
        outfile2.write(str(i*dx)+' '+str(j*dy)+' '+str(fwhm[i,scom[1]-1-j])+'\n')        
    
    for x in com1:
        outfile3.write(str(x)+'\n')    
    outfile1.close
    outfile2.close
    outfile3.close
  #####################################################################################
  # FIGURES FOR PUBLICATION
  #####################################################################################
  if opts.publish==1:
    user_dir = os.getcwd()
    sys.path.append(user_dir)
    from figures import figplot        
    com_exp = array(com)-com0
    thmid_exp=array(thmid)-thmid0
    thneg_exp=array(thneg)-thneg0
    thpos_exp=array(thpos)-thpos0
    #figplot(opts.transpose,dx,dy,indx1,indx2,indy1,indy2,thmid_exp,fwhm,peak)
    figplot(opts.transpose,dx,dy,indx1,indx2,indy1,indy2,peak,fwhm,stdev,com_exp,thmid_exp,thneg_exp,thpos_exp)
    sys.path.pop()

########################################################################################
## PLOT SLICES AND WRITE FILE
########################################################################################
                 
  if xsl >= 0 or ysl >= 0:    
      
      f3=plt.figure(3)         
      plt.suptitle(sbtitle0+sbtitle, size=20)  
      plt.subplot(331)
      peak_sl_m=np.ma.array(peak_sl,mask=peak_sl>100.0)
      plt.plot(range_sl,peak_sl_m)
      plt.title('normalized reflectivity',size=20)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(332)
      fwhm_sl_m=np.ma.array(fwhm_sl,mask=fwhm_sl>100.0*fwhm0)
      plt.plot(range_sl,fwhm_sl_m)
      plt.title('FWHM [urad]',size=20)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(333)
      stdev_sl_m=np.ma.array(stdev_sl,mask=stdev_sl>100.0*stdev0)
      plt.plot(range_sl,stdev_sl_m)
      plt.title('STDEV [urad]',size=20)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(334)
      com_sl_m=np.ma.array(com_sl,mask=com_sl>1.0e6)
      plt.plot(range_sl,com_sl_m)
      plt.title('COM (angle) [urad]',size=20)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(335)
      thmid_sl_m=np.ma.array(thmid_sl,mask=thmid_sl>1.0e6)
      plt.plot(range_sl,thmid_sl_m)
      plt.title('mid-point (angle) [urad]',size=20)
      plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')

      plt.subplot(336)
      thneg_sl_m=np.ma.array(thneg_sl,mask=thneg_sl>1.0e6)
      plt.plot(range_sl,thneg_sl_m)
      plt.title('left slope (angle) [urad]',size=20)
      plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')

      plt.subplot(337)
      thpos_sl_m=np.ma.array(thpos_sl,mask=thpos_sl>1.0e6)
      plt.plot(range_sl,thpos_sl_m)
      plt.title('right slope (angle) [urad]',size=20)
      plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')
      
  plt.show() 
  
  if opts.write is not None:
     header = '# '+ str(sys.argv) +'\n' \
            +'# version '+__version__+' by Stanislav Stoupin\n' \
            +'# Slices data\n' \
            +'# columns: \n' \
            '# '+str_axis+' peak(norm) FWHM[urad] COM[urad] mid-point[urad] left-slope[urad] right-slope[urad] STDEV[urad]\n'
     try:                
            writeFile(opts.write,header,range_sl,peak_sl_m,fwhm_sl_m,com_sl_m,thmid_sl_m,thneg_sl_m,thpos_sl_m,stdev_sl_m)
     except IOError, e:
            fatalIOError(e)                                        
                   
if __name__ == '__main__':
        options, args = ParseArguments(sys.argv[1:])
        main(options, args)                      
