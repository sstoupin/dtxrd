#!/usr/bin/env python
'''
a program for sequential topography/rocking curve imaging

:author:    Stanislav Stoupin
:email:     sstoupin@gmail.com

:copyright: Copyright 2014 by XSD, Advanced Photon Source, Argonne National Laboratory
:license:   UChicago Argonne, LLC Open Source License, see LICENSE for details.
'''

import os, sys
import numpy
import operator
import time

# LOCAL
#from numpy import *
#from pyhdf import *
#from curvestat import *
#from fit1d import *
#from myio import *
#from roll_zeropad import roll_zeropad

# GLOBAL
from dtxrd.pyhdf import *
from dtxrd.curvestat import *
from dtxrd.fit1d import *
from dtxrd.myio import *
from dtxrd.roll_zeropad import roll_zeropad

#from __future__ import division
#from matplotlib.patches import Patch
import matplotlib.image as mpimg
from pylab import *
from PIL import Image
#
#import matplotlib.style
#import matplotlib.pyplot as plt
import matplotlib as mpl
mver = mpl.__version__
ver_check = mver.split('.')
if float(ver_check[0]) >= 2:
    #mpl.style.use('classic')
    #-------------------------------
    ##########################################################
    ## to undo changes in matplotlib 2.1.0
    ##########################################################
    #mpl.rcParams['legend.fancybox'] = False
    #mpl.rcParams['legend.loc'] = 'upper right'
    #mpl.rcParams['legend.numpoints'] = 2
    #mpl.rcParams['legend.fontsize'] = 'large'
    #mpl.rcParams['legend.framealpha'] = None
    #mpl.rcParams['legend.scatterpoints'] = 3
    #mpl.rcParams['legend.edgecolor'] = 'inherit'
    mpl.rcParams['figure.figsize'] = [8.0, 6.0]
    mpl.rcParams['figure.dpi'] = 80
    mpl.rcParams['savefig.dpi'] = 100
    mpl.rcParams['font.size'] = 12
    mpl.rcParams['legend.fontsize'] = 'small'
    mpl.rcParams['figure.titlesize'] = 'medium'
    mpl.rcParams['image.cmap'] = 'jet'
# Open current folder when saving figures
user_dir = os.getcwd()
mpl.rcParams["savefig.directory"] = os.chdir(user_dir)
##################################################################
## fixed constants
##################################################################
r2d=180.0/pi
ftsize = 18         # figure title font size 
##################################################################

__version__='0.96'
prog = os.path.basename(sys.argv[0])
proginfo = prog + __version__ + ', by Stanislav Stoupin <sstoupin@gmail.com>'

#######################################################################################
# HISTORY
#######################################################################################
# 0. added gaussian fit for noisy data as an option "-g" v 0.2
# 1. need deglitching algorithm - done v 0.4
# 2. -b - custom background done v 0.4
# 3. calculate RMS and PV - done in v0.3
# 4. convenient output  done in v 0.3
# 5. a bug fixed with image orientation v 0.4 - for some reason the arrays have to be 
# transposed  v0.4
# 6. introduced colormap range factor (-f _value_  option)
# 7. statistics for selected rectangular region implemented   done v 0.6
# 9. need to sort data for every pixel based on angle values! done v 0.5
# 10. added upper limit on dyn_range (fixed value) 	      done v 0.51
# 11. added search for peak index to improve gaussian fit     done v 0.52
# 12. move dyn_range and other constants to the beginning
#	introduce df as an input parameter to the parser      done v 0.61
#	deglitch by default				      done v 0.63
# 	improve threshold upper limit processing	      done v 0.63
#       subtract bkg from peak data                           done v 0.63
#       add bkg0 - dark current 			      done v 0.64
# 13. improve glitch and background determination (4 points)  done v 0.65
# v 066  fliplr applied to flip left to right so that the images show up as the 
#        incident beam sees them
#        added sample name to report plot as an option
# v067   additional pixel rejection criteria based on the bkg level and on the 
#        COM and FWHM values (worked with Si 220 transmission data)
#        eventually best way to reject bad pixels - just treshold (e.g. -t 1.2)
# v068   added support for hdf5 files 
#        introduced instrument files ccd.py
# v069   minor iteration to adapt to data from topolab (Tim Madden's CCD)
# v070   added a capability to extract and plot slices
#        rearrangement of output files - now separate files for statistics and map data
# v071   fixed input for rotated matrixes 
#        now absence of transpose card processes images which correspond to as collected
#        data - the image is rotated in the data acquisition software so that the desired 
#        is obtained and this orientation is preserved with absence of transpose (-s) 
#        card in the processed rocking curve maps
# v072   added command line to the bottom of the main figure
# v073   switched rollzeropad to global import
# v074   disable writing map data with -o option 
#        -w option only makes sense when saving slices
# v075   when importing modules point to user_dir through os.getcdw()
#        append to path and when import is done exclude sys.path.pop()
# v076   introduced calculation for total rocking curve over the selected region 
#        output for prcurve(pixel) and trcurve(total/region) in the same file
# v077   improve logic on handling integrated reflectivity (now possible to integrate 
#        and normalize)
# v078   began work on implementing transmissivity measurements
# v079   further changes in handling TC data: 
#        background rejection on overall baseline transmissivity (bkg0) and 
#        the strength of the effect (tr ~ 0.01)
# v080   now processing forward diffracted topographs (transmission) 
#        with an option -c (--conduct)
# v081   now can process sequence of tiff (or other image) files using an external angular
#        scale from first column of a data file e.g. SPECfile.dat (-e SPECfile.dat)
# v082   linear interpolation for the background
# v083   found that simps failed on one of the samples NDT111-3_Bc2
#        modified curvestat to avoid simps - just using plain sums now
# v084   changed IOError, e: to IOError as e:
# v085   now rcurve_tot calculated after pixel rejection which is more correct 
#        the result is less dependent on the choice of region
# v086   making cosmetic changes, adapting for python3
# v087   transition from ancient optik parser to argparse
# v088   write processed data to h5 file "-j" option
# v089   remove integration for z = 1 (or z >1) option - to plot raw peak reflectivity counts
# v090   remove list of input files from "param" and write it to h5 file
# v091   began attempt to onclick local rocking curve
# v092   finalize onclick - now working
# v093   now deglitching with medfilt
# v094   changes to colorbar scaling to make compatible with rctopo-new/fast
#        fix analysis of the total RC
#        saving .h5 and .tif in the same format like rctopo-fast
# v095   changed colormap range on thneg and thpos so that it is centered around mean
# v096   added glob.glob to read '*' mask properly in WIN, behavior in linux is not compromised
#######################################################################################
#  TODO LIST
#######################################################################################
# 0. improve comput. speed? ADDRESSED by rctopo-fast
# 1. need mouse click access to each point on the maps - done v 0.92
# 2. figure out how to handle image rotations (reference)
# 3. presentation of Gaussian fit STDEV, COM ???
# 4. saving TIF
# 5. improve saving HDF5
####################################################################################### 

def residuals(p,y,x):
        return y-gauss(p,x)
def residuals0(p,y,x):
        return y-gauss0(p,x)

def fatalError(msg):
        sys.stderr.write('Error: ')
        sys.stderr.write(str(msg)) 
        sys.stderr.write('\n')
        sys.exit(1)

def fatalIOError(err):
        if issubclass(err.__class__, IOError) and err.strerror and err.filename:
                  err = '%s: %s' % (err.strerror, err.filename)
        fatalError(err)
                                                                
def ParseArguments():
        import argparse   # requires Python 2.7 or higher
        msg = prog + '  version: ' + __version__ + '\n'*2 + __doc__.strip()+'\n'

        #USAGE = prog + ' [OPTIONS...] filename1 filename2 ... \n' \
        #+'the program computes and displays rocking curve maps using a series of CCD \n' \
        #+'images taken at different angles on the rocking curve of a crystal\n' \
        #+'for options type: rctopo -h \n' \
        #+'Cheers!'
        #VERSION = '%prog ' + __version__ + ', by Stanislav Stoupin <sstoupin@aps.anl.gov>\n' 
        #parser = OptionParser(usage=USAGE, version=VERSION)                        
        parser = argparse.ArgumentParser(prog=prog, description=msg, formatter_class = argparse.RawDescriptionHelpFormatter)
        parser.add_argument('-v', '--version', action='version', version=__version__)        
        parser.add_argument('-o', '--output', action='store', dest='output', default=None, metavar='F',
                help='write calculated parameters to file F (defaults to stdout); also, write output for 1pix_total.dat')
        parser.add_argument('-w', '--write', action='store', dest='write', default=None, metavar='D',
                help='write data to file D (default: do not write) - reserved for slice data')
        parser.add_argument('--hdf5', action='store', dest='hdf5', default=None, metavar='D',
                         help='write data to hdf5 file D (default: do not write)')  
        parser.add_argument('-j', '--tif', action='store_const', dest='tif', const=1, default=0, 
                         help='save RC topographs as tif datafiles (default: do not save)')                                       
        parser.add_argument('-t', '--threshold', action='store', dest='tr', default=1.05, metavar='CONST',
                help='processing threshold for reflectivity to define the boundaries of the crystal')
        parser.add_argument('-b', '--background', action='store', dest='bkg', default=-1, metavar='CONST',
                help='background from CCD')
        parser.add_argument('-a', '--ashift', action='store', dest='ashift', default=0, metavar='CONST',
                help='compensate beam shift in the imaging plane at a distance CONST [m] (untested option)')
        parser.add_argument('-r', '--range', action='store', dest='rng', default='-1 -1 -1 -1', metavar='STRING',
                help='range selected for analysis STRING=\'x1 x2 y1 y2\' ')
        parser.add_argument('-x', '--xslice', action='store', dest='xsl', default=-1, metavar='CONST',
                help='slice and plot distribution at a fixed coordinate X')
        parser.add_argument('-y', '--yslice', action='store', dest='ysl', default=-1, metavar='CONST',
                help='slice and plot distribution at a fixed coordinate Y')
        parser.add_argument('-n', '--name', action='store', dest='nm', default='', metavar='STRING',
                help='sample name')        
        #        help='factor*fwhm_aver defines range of colormap on peak/slope position images')
        #        help='expand/shrink colormap range for fwhm by this factor')
        parser.add_argument('-f', '--factor', action='store', dest='f', default=1.0, metavar='CONST',
                help='scale factor for colormap range on FWHM and STDEV topographs')
        parser.add_argument('-m', '--magnify', action='store', dest='m', default=1.0, metavar='CONST',
                help='scale factor for colormap range on COM, Midpoint, Left Slope and Right Slope topographs')                        
        parser.add_argument('-d', '--deglitch', action='store', dest='degl', default=-1.0, metavar='CONST',
                help='deglitch data using median filtering, -d S, where S is the size of the filter window')
        parser.add_argument('-g', '--gaussian', action='store_const', const=1, dest='stat', default=0,
                help='do gaussian curve fitting (can help with noisy data)')
        parser.add_argument('-s', '--transpose', action='store_const', const=1, dest='transpose', default=0,
                help='transpose images for plotting')
        parser.add_argument('-u', '--units', action='store', dest='units', default='deg', metavar='STRING',
                help='angular units: deg, arcsec, urad')
        parser.add_argument('-p', '--publish', action='store_const', const=1, dest='publish', default=0,
                help='generate figures for publication (execute instructions in file figures.py)')
        parser.add_argument('-c', '--conduct', action='store_const', const=1, dest='conduct', default=0,
                help='process diffraction images collected in transmission')
        parser.add_argument('-i', '--instrument', action='store_const', const=1, dest='instrument', default=0,
                help='read parameters from instrument file ccd.py')                                                                       
        parser.add_argument('-z', '--integrate', action='store', dest='z', default=0, metavar='CONST',
                help='presentation of reflectivity data: \n'
                + 'z == 0  - plot peak reflectivity normalized by max. value (default) \n'
                + 'z == -1 - plot integrated reflectivity normalized by max. value \n'
                + 'z !=0 and z !=-1 - raw reflectivity data normalized by input parameter CONST')
        parser.add_argument('-e', '--external', action='store', dest='external', default=None, metavar='FILENAME',
                help='read angular steps from 1st column of an ASCII file (e.g., SPEC scan)')
        #
        parser.add_argument('input_files',nargs='+',
                help='list of input filenames')
        return parser.parse_args()
#        
# Cross-platform (converts * mask  into a list for WIN)
import glob
if '*' in sys.argv[-1]:
     sys.argv[-1:] = glob.glob(sys.argv[-1])
###############################################################################                                                                
def main():
  opts = ParseArguments()
  if opts.output is not None:
     try:
        outFile = open(opts.output, 'w')
     except IOError as e:
        fatalIOError(e)
  else:
     outFile = sys.stdout
  
  nall = len(sys.argv)-len(opts.input_files)
  param = sys.argv[0:nall]  
  param = ' '.join(param)
  outFile.write(str(param) + '\n')                    
  #outFile.write(str(opts)+' '+str(args)+'\n')
  outFile.write(prog + ' v '+__version__+'\n')
  outFile.write('range (x1 x2 y1 y2): '+opts.rng+'\n')
  
#----------------------------------------------------- 
# initialize & set constants      
#-----------------------------------------------------
  alldata=[]
  data=[]
  th_deg=[]
  tr=float(opts.tr)  #;   print("Threshold (tr) = ", tr)
  #df=int(opts.degl) #; print("Size of median filter window for deglitching (df) = ", df)
  sf=float(opts.f)   #;    print("Limit scale factor for plotting (sf) = ", sf)
  mf=float(opts.m)   #;    print("Shrink FWHM colormap range", mf)
  nf=len(opts.input_files) #;  print("Number of files to analyze = ", nf)
  zf=float(opts.z)   #;    print("integrate reflectivity (==0 no, !=0 yes, ==-1 normalize)", zf)
  #-------------------------------------------------------------------------------------------
  if opts.instrument == 1:  # if instrument file ccd.py is used
    user_dir = os.getcwd()
    sys.path.append(user_dir)
    from ccd import rbin,dx,dy,tot_range,dyn_range,fwhm_0,bkg0,data_path,th_path,chi_path   # import parameters from ccd.py  
    sys.path.pop()
  else:
    rbin=1
    dx, dy = 1.0, 1.0  # CCD camera pixel size [mm]    
    tot_range=10000.0     # upper limit for threshold processing (to exclude "dead" pixels)
    dyn_range=10000.0      # upper limit for threshold processing (gauss)
    fwhm_0=30.0        # expected fwhm (for fitting) 
    bkg0=2750.0        # "reasonable" background - dark current count       
    # default paths in hdf or h5 file    
    data_path='/entry/instrument/detector/data'
    th_path='/entry/instrument/detector/NDAttributes/theta'
    chi_path='/entry/instrument/detector/NDAttributes/chi'
  dx=float(rbin)*dx
  dy=float(rbin)*dy
  ##
  if opts.external is not None:
    fn_ang = str(opts.external) # read scan ascii file (SPEC scan or other)
    d1,d2=readFile(fn_ang)
    checkext = fn_ang.split('.')
    if checkext[1] == 'asc':
        angle_v = 1.0*d2[:,1]
    else:
        angle_v = 1.0*d2[:,0]
#---------------------------------------------------------------------------------------------  
  fn_count = 0 
  for fn in opts.input_files:   
    fn_ext=fn.split(".")[-1]
    if fn_ext == "hdf":
      angle, size, im = read_hdf4(fn)
      chi = -9999
      dx=0.06; dy=0.06
    elif fn_ext == "h5":
      angle, chi, size, im = read_hdf5(fn,rbin,data_path,th_path,chi_path) 
    #  
    elif fn_ext == "tiff" or fn_ext == "tif" or fn_ext == "png" or fn_ext == "jpg" or fn_ext == "jpeg":        
        im = mpimg.imread(fn) # read image   
        shape0 = im.shape
        if len(shape0) == 2:             
            (ny,nx) =  shape0
            res = 1
        elif len(shape0) == 3:
            (ny,nx,res) = shape0
            im = im[:,:,0] # added for Merlin        
        chi = -9999
        angle = angle_v[fn_count]
        ######################
        ## REBIN #############
        #            
        shape1 = (ny//rbin,nx//rbin)
        im = rebin(im,shape1)        
        (ny,nx) = shape1       
        size = [ny,nx]        
        #print "nx = ", nx
        #print "ny = ", ny           
        im = transpose(im)
    else:
      fatalError('Supported files are: hdf4 (ext .hdf), hdf5 (ext h5), image file (ext tif,tiff,png,jpg or jpeg)')  
#   
    if opts.transpose == 0:
        im=transpose(im)
        im=fliplr(im)
        nx=size[1]
        ny=size[0]
    else:             
        nx=size[0] #;print nx
        ny=size[1] #;print ny            
        im=flipud(im)
#  print im.dtype
    print("filename: ", fn)
    print("fn_count: ", fn_count)
    print("theta = ", angle)
    print("chi = ", chi)
### sorting data by angle #######################
    data_fn=[angle,im]
    alldata=alldata+[data_fn]
    fn_count = fn_count + 1
    #
  alldata=sorted(alldata,key=operator.itemgetter(0))
#################################################    
  
  for x in alldata:
    th_deg=th_deg+[x[0]]            

  if opts.units=='deg':
    th=1.0e6*array(th_deg)/r2d # th_deg in degrees
  elif opts.units=='arcsec':
    th=1.0e6*array(th_deg)/(60.0)**2.0/r2d     #th_deg in arcseconds
  elif opts.units=='urad':
    th=array(th_deg)                           # th_deg in urad
  elif opts.units=='um':
    th=5.86*array(th_deg)                      # th_deg in microns
  elif opts.units=='volt':
    #th=22.1388*array(th_deg)                      # th_deg in microns
    th=26.5*array(th_deg)
  else: 
    fatalIOError("Inappropriate angular units chosen")

################################################################################
## theta origin is defined here as the center of the angular range in the scan 
################################################################################
  th_beg=th[0]
  th_end=th[-1]
  th0=0.5*(th_beg+th_end)  
  th0_deg=1.0e-6*r2d*th0
  #
  ugol=th-th0  
  print("###########################################")
  print("th0 (initial) = ", th0)

  if opts.ashift == 0:
     for x in alldata:
         data=data+[x[1]]
  else:
     from ccd import th0
     #from roll_zeropad import roll_zeropad
     for (t,x) in map(None,th,alldata): 
        imdist = float(opts.ashift) # [m]
        imsh = 1.0e-6*(t-th0)*imdist*1.0e3 # image shift [mm]
        print("applied shifts [mm] =  ", imsh)
        print("th0 [urad] = ", th0)
        rind = int(imsh/dy); print("rind = ", rind)
        #sarray = roll(x[1],-rind,axis=0)
        sarray = roll_zeropad(x[1],-rind,axis=0)        
        data = data +[sarray]                                                 
  data=array(data); #print data
    
####################################################
## Analyzed Area (Range)
####################################################
  step=1
  #    
  rangexy=opts.rng.split(' ')    
  rngx1=float(rangexy[0]); rngy1=float(rangexy[2])
  rngx2=float(rangexy[1]); rngy2=float(rangexy[3])
  
  if rngx1<0:
    indx1=0
  else:
    indx1=int(rngx1/dx)
  if rngy1<0:
    indy1=0
  else:
    indy1=int(rngy1/dy)
#---------------------------------------  
  if rngx2<0 or rngx2>nx*dx:
    indx2=nx
  else:  
    indx2=int(rngx2/dx)
  if rngy2<0 or rngy2>ny*dy:
    indy2=ny
  else:
    indy2=int(rngy2/dy)        
  
  xrange=arange(nx-indx2,nx-indx1,step) #;print "xrange = ", xrange
  yrange=arange(ny-indy2,ny-indy1,step) #;print "yrange = ", yrange
#-----------------------------------------------------
#initialize arrays
#-----------------------------------------------------
  peak=numpy.empty((nx,ny))  #1
  fwhm=numpy.empty((nx,ny))  #2
  thmid=numpy.empty((nx,ny)) #3
  com=numpy.empty((nx,ny))   #4
  thneg=numpy.empty((nx,ny)) #5
  thpos=numpy.empty((nx,ny)) #6
  stdev=numpy.empty((nx,ny)) #7
  fwhm1=[]; peak1=[]; thmid1=[]; com1=[]; thpos1=[]; thneg1=[]; stdev1=[] # arrays to calclulate rms and pv
  rcurve_tot = [] # initialize total rcurve list
#-------------------------------------------------------    
  if float(opts.bkg) > 0:
    bkg=float(opts.bkg)
    print("bkg is assigned through option, bkg = ", bkg)
  else:
    print("bkg approximated by the endpoints")
#-------------------------------------------------------  
  abs_max=data.max(); print ('abs_max = ', abs_max)
#-------------------------------------------------------  
# Main stuff
#-------------------------------------------------------
  timing_start = time.time()
  for j in yrange:
    for i in xrange:
      rcurve=data[:,j,i]
      #-------------------------------------------------
      # Background determination
      #-------------------------------------------------
      if opts.bkg==-1:    
        bkg=0.25*(rcurve[0]+rcurve[1]+rcurve[len(rcurve)-2]+rcurve[len(rcurve)-1]) #; print 'bkg = ', bkg  
        b1=0.5*(rcurve[0]+rcurve[1])
        b2=0.5*(rcurve[len(rcurve)-2]+rcurve[len(rcurve)-1])
        t1=th_beg
        t2=th_end
        A=(b2-b1)/(t2-t1)
        B=b2-A*t2
        bkg_lin=A*th+B
      #------------------------------------------------
      # Deglitching procedure
      #------------------------------------------------                  
      if opts.degl !=-1:
          from scipy.signal import medfilt
          df = abs(int(opts.degl))
          rcurve = medfilt(rcurve,kernel_size=df)
      #---------------------------------------------------------------------------------------
      # subtracting bkg since it can vary from pixel to pixel            
      if opts.conduct == 1:
          rcurve = -1.0*(rcurve-bkg_lin)  # TC
          bkgs = 0.0    # TC      
          rcmax=max(rcurve)
          rmax=rcmax       # TC
          #rmax=bkg        # TC
      if opts.conduct == 0:
          bkgs = bkg  #RC
          rcmax=max(rcurve)
          rmax=rcmax-bkg # RC     
      ###debug:  
      #print 'rmax= ', rmax
      #---------------------------------------------------------------------------------------
#     tot=sum(rcurve)/len(rcurve)      #; print 'tot = ', tot
      rcurve_l=list(rcurve)
      max_i=rcurve_l.index(rcmax)
      thi0=th[max_i]-th0
      #---------------------------------------------------------      
      # define central pixel                                     
      indx0=int(0.5*(xrange[0]+xrange[len(xrange)-1]))
      indy0=int(0.5*(yrange[0]+yrange[len(yrange)-1]))
      #--------------------------------------------------------
      if (i==indx0) and (j==indy0):
            print("thi0 = ", thi0)
            #ugol=th-th0 #th_deg    
            p0=[bkgs,rcmax,thi0,fwhm_0] #bkg max center
            p, unc, dte, stat, cov = fit1d(residuals,p0,ugol,rcurve) 
            com0=sum((rcurve-p[0])*(ugol))/sum(rcurve-p[0]); print("com = ", com0)
            print('--------------------------------------------------------------------------')
            print('Gaussian fit at the central pixel')
            print('X0 [mm] = ', float(xrange[0] + indx0)*dx)
            print('Y0 [mm] = ', float(yrange[0] + indy0)*dy)
            print('bkg  = ', bkg)
            print('bkgs = ', bkgs)
            print('p = ', p)
            print('FWHM =', 2.0*abs(p[3])*sqrt(log(2)), ' urad')
            #--------------------------------------------------
            # assign rcurve from pixel for output
            # subtract background 
            prcurve = rcurve - bkgs               
            ##################################################################################              
            # start plotting things ----------------------------------
            mpl.rcParams.update({'font.size': 12})
            f1=plt.figure(figsize=(8.0,7.0))
            plt.plot(ugol,prcurve, 'bo',label="local RC") 
            plt.plot(ugol,prcurve, 'b-')
            ugol_g=arange(ugol[0],ugol[len(ugol)-1]+0.1,0.1)
            plt.plot(ugol_g,ugol_g*0, color='k', label='baseline (subtracted bkg)')
            plt.plot(ugol_g,gauss(p,ugol_g)-p[0],'b--',label="Gauss. fit for local RC")            
            plt.title ('pixel location [mm]: X ='+str(round((nx-i)*dx,3))+', Y = '+str(round((ny-j)*dy,3)),size=16) 
            plt.xlabel('$\\theta - \\theta_0$, [$\mu$rad]', size=16)
            plt.ylabel('Counts', size=16)                                        
################################################################################################################## 
####### PIXEL REJECTION CRITERIA ################################################################################# 
##################################################################################################################  
      if opts.conduct == 0: #RC
          crit1 = bkg<dyn_range*bkg0 and rcmax>tr*bkg and rcmax<tot_range*bkg0            
      elif opts.conduct == 1: #TC
          crit1 = bkg<dyn_range*bkg0 and rcmax>tr*bkg and rcmax<tot_range*bkg0 and bkg>bkg0
      # explicitly:          
      #if bkg<dyn_range*bkg0 and rcmax>tr*bkg and rcmax<tot_range*bkg0:  #RC
      #if bkg<dyn_range*bkg0 and rcmax>tr*bkg and rcmax<tot_range*bkg0 and bkg>bkg0:            #TC 
      if crit1 == True:
          # add rcurve to rcurve_tot - afer deglitching if it is activated
          # AND after pixel rejection criteria
          rcurve_tot = rcurve_tot + [rcurve]       
          ##################################################################################
          # extracting curve parameters if the pixel complies with the criterion
          ##################################################################################                        
          if opts.stat==1:
                p0=[bkgs,rcmax,thi0,fwhm_0]
                p, unc, dte, stat, cov = fit1d(residuals,p0,th-th0,rcurve)
                if opts.conduct == 0: #RC
                  crit2 = abs(p[1]) < dyn_range*bkg0 and abs(p[2]) < 0.5*abs(th_end-th_beg) and abs(p[3]) < abs(th_end-th_beg)  # and cov !='NA' # as an option
                elif opts.conduct == 1: #TC  
                  crit2 = abs(p[1]) < dyn_range*bkg0 and abs(p[1])>tr*bkg and abs(p[2]) < 0.5*abs(th_end-th_beg) and abs(p[3]) < abs(th_end-th_beg)
                #if abs(p[0]) < dyn_range*bkg0 and abs(p[2]) < 0.5*abs(th_end-th_beg) and abs(p[3]) < abs(th_end-th_beg):  # and cov !='NA' # as an option
                #if abs(p[0]) < dyn_range*bkg0 and abs(p[1])>tr*bkg and abs(p[2]) < 0.5*abs(th_end-th_beg) and abs(p[3]) < abs(th_end-th_beg):  # TC 
                if crit2 == True:
                  #
                  fwhm_g=2.0*abs(p[3])*sqrt(log(2.0))
                  fwhm[i,j]=fwhm_g;   fwhm1=fwhm1+[fwhm[i,j]]                  
                  if zf == 0: 
                      if opts.conduct == 0:    peak[i,j] = p[1]      #RC
                      elif opts.conduct == 1:  peak[i,j] = p[1]/bkg  #TC                 
                  elif zf == -1:
                      if opts.conduct == 0: peak[i,j] = abs(p[1])*abs(p[3])*sqrt(pi)/abs(zf)
                      if opts.conduct == 1: peak[i,j] = abs(p[1])*abs(p[3])*sqrt(pi)/abs(zf)/bkg
                  else:
                      peak[i,j] = p[1]/abs(zf)
                      #if opts.conduct == 0:    peak[i,j] = p[1]      #RC
                      #elif opts.conduct == 1:  peak[i,j] = p[1]/bkg  #TC  
                  ##---------------------------------------------------------    
                  peak1=peak1+[peak[i,j]]   # p[1] - in gauss function background already subtracted               
                  thmid[i,j]=p[2];       thmid1=thmid1+[thmid[i,j]]
                  #com[i,j]=sum((rcurve-p[0])*(th-th0))/sum(rcurve-p[0]); com1=com1+[com[i,j]]                                    
                  com[i,j]=p[2];         com1=com1+[com[i,j]]               
                  stdev[i,j]=abs(p[3])/sqrt(2.0); stdev1=stdev1+[stdev[i,j]]
                  thneg[i,j]=p[2]-fwhm_g/2.0; thneg1=thneg1+[thneg[i,j]]
                  thpos[i,j]=p[2]+fwhm_g/2.0; thpos1=thpos1+[thpos[i,j]]
                else:
                  fwhm[i,j]=1e9
                  peak[i,j]=1e9
                  thmid[i,j]=1e9
                  com[i,j]=1e9
                  thneg[i,j]=1e9
                  thpos[i,j]=1e9  
                  stdev[i,j]=1e9
          else:
              try: 
                stat=curvestat(th-th0,rcurve,bkgs)
                #
                if opts.conduct == 0:
                  crit2 = abs(stat[1]-bkgs) < dyn_range*bkg0 and abs(stat[6]) < 0.5*abs(th_end-th_beg) and abs(stat[5]) < abs(th_end-th_beg)
                if opts.conduct == 1:
                  crit2 = abs(stat[1]-bkgs) < dyn_range*bkg0 and abs(stat[1])>tr*bkg and abs(stat[6]) < 0.5*abs(th_end-th_beg) and abs(stat[5]) < abs(th_end-th_beg)
                #
                if crit2 == True:
                  fwhm[i,j]=stat[5];         fwhm1=fwhm1+[fwhm[i,j]]                  
                  if zf == 0:
                      if opts.conduct == 0:   peak[i,j]=stat[1]-bkgs   #RC
                      elif opts.conduct == 1: peak[i,j]=stat[1]/bkg    #TC
                  elif zf == -1:
                      if opts.conduct == 0:   peak[i,j]=stat[8]/abs(zf)
                      elif opts.conduct == 1: peak[i,j]=stat[8]/abs(zf)/bkg   
                  else: 
                      peak[i,j]=stat[1]/abs(zf)
                      #                                            
                  peak1=peak1+[peak[i,j]]         # peak intensity                 
                  thmid[i,j]=stat[4];             thmid1=thmid1+[thmid[i,j]]
                  com[i,j]=stat[6];               com1=com1+[com[i,j]]
                  stdev[i,j]=sqrt(abs(stat[7]));  stdev1=stdev1+[stdev[i,j]]  # variance to standard deviation
                  thneg[i,j]=stat[2];             thneg1=thneg1+[thneg[i,j]]
                  thpos[i,j]=stat[3];             thpos1=thpos1+[thpos[i,j]]
                else:
                  fwhm[i,j]=1e9
                  peak[i,j]=1e9
                  thmid[i,j]=1e9
                  com[i,j]=1e9
                  thneg[i,j]=1e9
                  thpos[i,j]=1e9
                  stdev[i,j]=1e9                                                            
              except UnboundLocalError:
                fwhm[i,j]=1e9
                peak[i,j]=1e9
                thmid[i,j]=1e9
                com[i,j]=1e9
                thneg[i,j]=1e9
                thpos[i,j]=1e9
                stdev[i,j]=1e9
          
      else:  
        fwhm[i,j]=1e9
        peak[i,j]=1e9
        thmid[i,j]=1e9
        com[i,j]=1e9
        thneg[i,j]=1e9
        thpos[i,j]=1e9
        stdev[i,j]=1e9

  print("DIAGNOSTIC: double for loop complete in %f seconds" % (time.time() - timing_start))            
  norm=max(peak1)  
  print("norm = ", norm)

  if opts.conduct == 0:
    if zf == 0 or zf == -1:
      peak=peak/norm 
      peak1=peak1/norm
  elif opts.conduct == 1:
    if zf == -1:
      peak=peak/norm 
      peak1=peak1/norm        
  
  fwhm1=array(fwhm1)
  stdev1=array(stdev1)
  peak1=array(peak1)
  thmid1=array(thmid1)
  com1=array(com1)  
  thneg1=array(thneg1)
  thpos1=array(thpos1)
  
  out='------------------------------------------------------------------------\n'
  #----------------------------------------------------------------------------------
  fwhm0=mean(fwhm1);            out = out + "FWHM_average = %f " % fwhm0 +" urad\n"
  fwhm_rms=std(fwhm1);             out = out + "FWHM_rms = %f "     % fwhm_rms +" urad\n"
  fwhm_pv=amax(fwhm1)-amin(fwhm1); out = out + "FWHM_pv =  %f "     % fwhm_pv +" urad\n"
  #----------------------------------------------------------------------------------
  stdev0=mean(stdev1);             out = out + "STDEV_average = %f " % stdev0 +"urad\n"
  stdev_rms=std(stdev1);              out = out + "STDEV_rms = %f "     % stdev_rms +" urad\n"
  stdev_pv=amax(stdev1)-amin(stdev1); out = out + "STDEV_pv = %f "      % stdev_pv +" urad\n"
  #----------------------------------------------------------------------------------
  peak0=mean(peak1);               out = out + "Intens_average = %f " % peak0 +"\n"
  peak_rms=std(peak1);             out = out + "Intens_rms = %f "     % peak_rms +"\n"
  peak_pv=amax(peak1)-amin(peak1); out = out + "Intens_pv = %f "      % peak_pv +"\n"
  #----------------------------------------------------------------------------------
  com0=mean(com1);           out = out + "COM_average = %f " % com0 +" urad\n"
  com_rms=std(com1);            out = out + "COM_rms = %f "     % com_rms +" urad\n"
  com_pv=amax(com1)-amin(com1); out = out + "COM_pv = %f "      % com_pv +" urad\n"
  #----------------------------------------------------------------------------------
  thmid0=mean(thmid1);             out = out + "thmid_average = %f " % thmid0 +" urad\n"
  thmid_rms=std(thmid1);              out = out + "thmid_rms = %f "     % thmid_rms +" urad\n"
  thmid_pv=amax(thmid1)-amin(thmid1); out = out + "thmid_pv = %f "      % thmid_pv +" urad\n"
  #----------------------------------------------------------------------------------
  thneg0=mean(thneg1);             out = out +"thneg_average = %f " % thneg0 +" urad\n"
  thneg_rms=std(thneg1);              out = out + "thneg_rms = %f "    % thneg_rms +" urad\n"
  thneg_pv=amax(thneg1)-amin(thneg1); out = out + "thneg_pv = %f "     % thneg_pv +" urad\n"
  #----------------------------------------------------------------------------------
  thpos0=mean(thpos1);             out = out + "thpos_average = %f " % thpos0 +" urad\n"
  thpos_rms=std(thpos1);              out = out + "thpos_rms = %f "     % thpos_rms +" urad\n"
  thpos_pv=amax(thpos1)-amin(thpos1); out = out + "thpos_pv = %f "      % thpos_pv +" urad\n"
  out = out + '------------------------------------------------------------------------\n'
  #----------------------------------------------------------------------------------

##############################################################################
## Total rocking curve
##############################################################################
  rcurve_tot = array(rcurve_tot)
  trcurve =  sum(rcurve_tot,axis=0)/len(rcurve_tot)
  # Stats:
  if float(opts.bkg) > 0:
    bkg_tot = float(opts.bkg)
  else:   
    bkg_tot=mean((trcurve[0],trcurve[1],trcurve[-2],trcurve[-1])) 
  print('average subtracted bkg:')  
  print('bkg_tot = %f ' % bkg_tot)
  stat=curvestat(th-th0,trcurve,bkg_tot)
  #
  fwhm_tot=stat[5];                 out = out + "FWHM_tot = %f " % fwhm_tot +" urad\n"
  stdev_tot=sqrt(abs(stat[7]));     out = out + "STDEV_tot = %f " % stdev_tot +" urad\n"
  #
  if zf == 0:     
      peak_tot = (stat[1] - bkg_tot)/norm
  elif zf == -1:  
      peak_tot = stat[8]/norm
  else:               
      peak_tot = (stat[1] - bkg_tot)/abs(zf)
  out = out + "Intens_tot = %f " % peak_tot +"\n"
  #
  com_tot=stat[6];                  out = out + "COM_tot = %f "   % com_tot +" urad\n"                                            
  thmid_tot=stat[4];                out = out + "thmid_tot = %f " % thmid_tot +" urad\n"   
  thneg_tot=stat[2];                out = out + "thneg_tot = %f " % thneg_tot +" urad\n"
  thpos_tot=stat[3];                out = out + "thpos_tot = %f " % thpos_tot +" urad\n"
  # substract background from the total curve for plotting and output:
  trcurve = trcurve - bkg_tot
  plt.plot(ugol,trcurve, 'ro',label="total RC")
  plt.plot(ugol,trcurve, 'r-')
  plt.legend(loc='upper right',fontsize=10)
##################################################################################
## Write output									
##################################################################################
  outFile.write('------------------------------------------------------------------------\n')
  outFile.write('peak max = '+str(norm)+'\n')
  outFile.write('threshold = '+str(tr)+'\n')        
  outFile.write('-----------------Statistics---------------------------------------------\n')
  outFile.write(out)
  outFile.close
    
  if opts.output is not None:
      header="# RC from the selected pixel and total rocking curve over selected region \n# columns: angle intensity\n"
      writeFile("prcurve.dat", header, ugol, prcurve)                                                   
      header="# RC total rocking curve over selected region \n# columns: angle trcurve\n"
      writeFile("trcurve.dat", header, ugol, trcurve)                                                   
##################################################################################  
##  Plot results
##################################################################################
  # need to "mirror" y indexes because in an array numbering starts from top left corner
  # affects only choice of range - does not affect plotting 
  # same for x since it was found that the image has to be reversed in x direction
  # note that for x fliplr is applied later while for y imshow origin='upper'

  nnx1=nx-indx2; nnx2=nx-indx1
  nny1=ny-indy2; nny2=ny-indy1
                
  fwhm=fwhm[nnx1:nnx2,nny1:nny2]
  stdev=stdev[nnx1:nnx2,nny1:nny2]
  peak=peak[nnx1:nnx2,nny1:nny2]
  thmid=thmid[nnx1:nnx2,nny1:nny2]
  com=com[nnx1:nnx2,nny1:nny2]
  thneg=thneg[nnx1:nnx2,nny1:nny2]
  thpos=thpos[nnx1:nnx2,nny1:nny2]  

#######################################################
## Extract slices
#######################################################  
  xsl=float(opts.xsl)
  ysl=float(opts.ysl)
  if xsl >= 0:
      indxsl = nx-int(xsl/dx) - nnx1
      #      
      peak_sl = peak[indxsl,:]
      fwhm_sl = fwhm[indxsl,:]
      stdev_sl = stdev[indxsl,:]
      com_sl = com[indxsl,:]
      thmid_sl = thmid[indxsl,:]
      thneg_sl = thneg[indxsl,:]
      thpos_sl = thpos[indxsl,:] 
      range_sl = dy*arange(indy1,indy2)
      sbtitle0 = 'Slices at X = '+str(xsl)+' '
      str_axis='y [mm]'
  #----------------------------------    
  if ysl >= 0:
      indysl = ny-int(ysl/dx) - nny1
      #
      peak_sl = peak[:,indysl]
      fwhm_sl = fwhm[:,indysl]
      stdev_sl = stdev[:,indysl]
      com_sl = com[:,indysl]
      thmid_sl = thmid[:,indysl]
      thneg_sl = thneg[:,indysl]
      thpos_sl = thpos[:,indysl]
      range_sl = dx*arange(indx1,indx2)
      sbtitle0 = 'Slices at Y = '+str(ysl)+' '      
      str_axis='x [mm]'
  #
  fwhm=transpose(fwhm)
  stdev=transpose(stdev)
  peak=transpose(peak)
  thmid=transpose(thmid)
  com=transpose(com)
  thneg=transpose(thneg)
  thpos=transpose(thpos)
  
  peak=fliplr(peak)
  fwhm=fliplr(fwhm)
  stdev=fliplr(stdev)  
  thmid=fliplr(thmid) 
  com=fliplr(com) 
  thneg=fliplr(thneg)
  thpos=fliplr(thpos)
  xyrange=(dx*indx1,dx*indx2,dy*indy1,dy*indy2)  # for some reason the arrays should be transposed   
  #
  if ysl >=0 or xsl >=0: 
      peak_sl=peak_sl[::-1]
      fwhm_sl=fwhm_sl[::-1]
      stdev_sl=stdev_sl[::-1]
      thmid_sl=thmid_sl[::-1]
      com_sl=com_sl[::-1]
      thneg_sl=thneg_sl[::-1]
      thpos_sl=thpos_sl[::-1] 
###################################################################################
## NOW PLOT EVERYTHING
###################################################################################
  fig=plt.figure(figsize=(22.0,12.2))
  if opts.stat==1: sbtitle='Gaussian curve fitting.'
  else:            sbtitle='No curve fitting.'
  #    
  sbtitle='Rocking curve topographs: '+sbtitle
  # Sample name      
  if opts.nm != '':
    sbtitle=sbtitle+' Sample: '+opts.nm  #+'\n' + param  
  plt.suptitle(sbtitle, size=ftsize)  
  plt.figtext(0.1,0.025,param)
  #------------------------------------------------------------------------------------------------------------------------------------
  ax1 = fig.add_subplot(331)
  peak_m = ma.array(peak,mask=peak>1.0e8/norm)
  if zf == 0:
      imgplot = ax1.imshow(peak_m, aspect='auto', extent=xyrange,vmin=0,vmax=1.0)
      if opts.conduct == 0:   ax1.set_title('Peak Intens. [n.u.]',size=ftsize)
      elif opts.conduct == 1: ax1.set_title('Peak Intens. [abs.u.]',size=ftsize)   # because this is absolute reflectivity!!!
      fig.colorbar(imgplot, ax=ax1)
  elif zf == -1:
     imgplot = ax1.imshow(peak_m, aspect='auto', extent=xyrange,vmin=0,vmax=1.0)
     if opts.conduct == 0:    ax1.set_title('Integrated Intens. [n.u.]',size=ftsize)
     elif opts.conduct == 1:  ax1.set_title('Integrated Intens. [n.u.]',size=ftsize)
     fig.colorbar(imgplot, ax=ax1)      
  else: 
      if opts.conduct == 0:   
          ax1.set_title('Intensity [cnt x 10$^3$]',size=ftsize)
          vmin0=min(peak1)/1.0e3; vmax0=max(peak1)/1.0e3
          peak_tr = 66000.0/1.0e3/abs(zf) #; print ('peak tr = ', peak_tr)          
          peak2 = peak/1.0e3
          peak_m2 = ma.array(peak2,mask=peak2>peak_tr)            
          imgplot = ax1.imshow(peak_m2, aspect='auto', extent=xyrange,vmin=vmin0,vmax=vmax0)      
      elif opts.conduct == 1: 
          plt.title('Intensity [cnt x 10$^3$]',size=ftsize)
          vmin0=min(peak1)/1.0e3; vmax0=max(peak1)/1.0e3
          peak_tr = 1.0e8/1.0e3/abs(zf) #; print ('peak tr = ', peak_tr)
          peak2 = peak/1.0e3
          peak_m2 = ma.array(peak2,mask=peak2>peak_tr)  
          imgplot = ax1.imshow(peak_m2, aspect='auto', extent=xyrange,vmin=vmin0,vmax=vmax0)
      
      fig.colorbar(imgplot, ax=ax1)
  #plt.xlabel('x [mm]')
  ax1.set_ylabel('y [mm]')

#  vmin0=round(fwhm_l*fwhm0,-1)
#  vmax0=round(fwhm_r*fwhm0,-1)
#  vmin0=round(fwhm0*(1.0-mf*sf))
#  vmax0=round(fwhm0*(1.0+mf*sf))
  vmin0=round(fwhm0*(1.0-sf)) # get rid of mf here to make scaling compatible with rctopo-new/fast
  vmax0=round(fwhm0*(1.0+sf))
  if vmin0 < 0: vmin0 = 0
  
  ax2 = fig.add_subplot(332)
  fwhm_m = ma.array(fwhm,mask=fwhm>1.0e8)
  imgplot = ax2.imshow(fwhm_m, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #, picker=1) #vmin=fwhm.min(),vmax=fwhm.max())
  fig.colorbar(imgplot, ax=ax2)
  ax2.set_title('FWHM [$\mu$rad]',size=ftsize)
  #ax2.set_xlabel('x [mm]')
  ax2.set_ylabel('y [mm]')

  #vmin0=round(stdev0*(1.0-mf*sf))
  #vmax0=round(stdev0*(1.0+mf*sf))
  vmin0=round(stdev0*(1.0-sf)) # get rid of mf here to make scaling compatible with rctopo-new/fast
  vmax0=round(stdev0*(1.0+sf))
  if vmin0 < 0: vmin0 = 0
    
  ax3 = fig.add_subplot(333)
  stdev_m = ma.array(stdev,mask=stdev>1.0e8)
  imgplot = plt.imshow(stdev_m, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=fwhm.min(),vmax=fwhm.max())
  plt.colorbar(imgplot, ax=ax3)
  ax3.set_title('STDEV [$\mu$rad]',size=ftsize)
  ax3.set_xlabel('x [mm]')
  ax3.set_ylabel('y [mm]')
  #grid(True)

  #vmin0=round(com0-sf*fwhm0)
  #vmax0=round(com0+sf*fwhm0)
  vmin0=round(com0-mf*fwhm0) # colorbars for angular characteristics are scaling with mf
  vmax0=round(com0+mf*fwhm0)
  
  ax4 = fig.add_subplot(334)
  com_m = ma.array(com,mask=com>1.0e8)
  imgplot = plt.imshow(com_m, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=com.min(),vmax=com.max())
  plt.colorbar(imgplot, ax=ax4)
  ax4.set_title('COM [$\mu$rad]',size=ftsize)
  #plt.xlabel('x [mm]')
  ax4.set_ylabel('y [mm]')

  #vmin0=round(thmid0-sf*fwhm0)
  #vmax0=round(thmid0+sf*fwhm0)
  vmin0=round(thmid0-mf*fwhm0)  # colorbars for angular characteristics are scaling with mf
  vmax0=round(thmid0+mf*fwhm0)

  ax5 = fig.add_subplot(335)
  thmid_m = ma.array(thmid,mask=thmid>1.0e8)
  imgplot = plt.imshow(thmid_m, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=thmid.min(),vmax=thmid.max())
  plt.colorbar(imgplot, ax=ax5)
  ax5.set_title('Midpoint [$\mu$rad]',size=ftsize)
  #plt.xlabel('x [mm]')
  ax5.set_ylabel('y [mm]')
  
  #ax6 = fig.add_subplot(336)
  #ax6.axis('off')

  #vmin0=round(thneg0-1.0*sf*fwhm0)
  vmin0=round(thneg0-1.0*mf*fwhm0)
  vmax0=round(thneg0+1.0*mf*fwhm0)
  #vmax0=round(thmid0)
  
  ax7 = fig.add_subplot(337)
  thneg_m = ma.array(thneg,mask=thneg>1.0e8)
  imgplot = plt.imshow(thneg_m, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=thneg.min(),vmax=thneg.max())
  plt.colorbar(imgplot, ax=ax7)
  ax7.set_title('Left Slope [$\mu$rad]',size=ftsize)
  ax7.set_xlabel('x [mm]')
  ax7.set_ylabel('y [mm]')
  
#  vmin0=round(com0-(sf-1.0)*fwhm0,-1)
  #vmin0=round(thmid0)
  #vmax0=round(thpos0+1.0*sf*fwhm0)
  vmin0=round(thpos0-1.0*mf*fwhm0)
  vmax0=round(thpos0+1.0*mf*fwhm0)
  
  ax8 = fig.add_subplot(338)
  thpos_m = ma.array(thpos,mask=thpos>1.0e8)
  imgplot = plt.imshow(thpos_m, aspect='auto', extent=xyrange, vmin=vmin0, vmax=vmax0) #vmin=thpos.min(),vmax=thpos.max())
  plt.colorbar(imgplot, ax=ax8)
  ax8.set_title('Right Slope [$\mu$rad]',size=ftsize)
  ax8.set_xlabel('x [mm]')
  ax8.set_ylabel('y [mm]')

  ##                       
  ax9 = fig.add_subplot(339)
  ax9.axis('off')
  ax9.text(0,-0.2,out,size=13)  
  #---------------------------------------------
  ############################################################
  # picker attempt:    
  ############################################################
  def onpick(event):
    if event.button == 3:
      xdata = event.xdata
      ydata = event.ydata
      #ind = event.ind
      xydata = (xdata, ydata) 
      print('--------------------------------------------------------------------------') 
      print('Local RC:')  
      print('onpick coordinates (X,Y): (%.3f, %.3f)' % xydata)
      idx = nx-int(ceil(xdata/dx))  # ceil works best, still needs further testing
      idy = ny-int(ceil(ydata/dy))  # ceil works best, still needs further testing 
      print('onpick indicies (Ix,Iy):', (idx,idy))
      #----------------------------------------------
      # plot local rocking curve
      #----------------------------------------------
      mpl.rcParams.update({'font.size': 12})
      fig=plt.figure(figsize=(8.0,7.0))
      rcurve00=data[:,idy,idx]
      b00=0.25*(rcurve00[0]+rcurve00[1]+rcurve00[-2]+rcurve00[-1])
      print('bkg (from tails) = %f' % b00)
      if opts.conduct == 1:
          rcurve00 = -1.0*(rcurve00 - b00)
      else: 
          rcurve00 = rcurve00 - b00      
      # begin plotting:
      plt.title ('pixel location [mm]: X ='+str(round(xdata,3))+', Y = '+str(round(ydata,3)),size=16) 
      plt.plot(ugol,rcurve00,'b-')
      plt.plot(ugol,rcurve00,'bo',label='local RC')
      plt.plot(ugol,ugol*0, color='k', label='baseline (subtracted bkg)')
      #Generic FWHM
      try: 
        result=curvestat(ugol,rcurve00,0.0)
        th_max00=result[0]; r_max00=result[1]
        th_neg00=result[2]; th_pos00=result[3]; th_mid00=result[4]
        fwhm00=result[5]; com00=result[6]
        stdev00=sqrt(abs(result[7]))
        print('Generic FWHM/COM:')
        print('r_max [ct] =  %f' % r_max00)
        print('th_max [urad] = %f' % th_max00)
        print('th_mid [urad] = %f' % th_mid00)
        print('com [urad] = %f' % com00)
        print('stdev [urad] =  %f' % stdev00)
        print('fwhm [urad] = %f'   %fwhm00)
        # Gaussian fit
        p00=[r_max00,com00,sqrt(2.0)*(fwhm00/2.355)] #bkg max center
        p, unc, dte, stat, cov = fit1d(residuals0,p00,ugol,rcurve00) 
        #com0=sum((rcurve-p[0])*(ugol))/sum(rcurve-p[0])
        stdev00 = abs(p[2])/sqrt(2.0)
        fwhm00 = 2.0*abs(p[2])*sqrt(log(2.0))
        #
        print('Gaussian fit:')
        print('r_max_g [ct] =  %f' % p[0])
        print('th_max_g [urad] = %f' % p[1])
        print('stdev_g [urad] =  %f' % stdev00)
        print('fwhm_g [urad] = %f'   %fwhm00)
        print('--------------------------------------------------------------------------')
        ugol_g=arange(ugol[0],ugol[-1]+0.1,0.1)
        plt.plot(ugol_g,gauss0(p,ugol_g),'b--',label="Gauss. fit") 
        plt.plot(ugol,0.5*(r_max00)+ugol*0, linestyle='--', color='k', label='half max.')
      except: 
        print('Curve statistics unobtainable')
      plt.xlabel('$\\theta - \\theta_0$, [$\mu$rad]', size=16)
      plt.ylabel('Counts', size=16)
      plt.legend(loc='upper left',fontsize=10)
      plt.show()
  #
  fig.canvas.mpl_connect('button_press_event', onpick)
#  plt.show()
  ################################
  # output for GLE
  ################################
#  thc=59.84
#  dx1=dx/sin(thc/r2d)
#  if opts.output is not None:
#    com_exp=array(com) #-com0    
#    #        
#    outfile1 = open('com.dat', 'w') 
#    outfile2 = open('fwhm.dat', 'w')
#    outfile3 = open('com1.dat', 'w')
#    scom=shape(com_exp) #print "scom =", scom
#    for i in range(0,scom[0],1):
#      for j in range(0,scom[1],1):
#        outfile1.write(str(i*dx)+' '+str(j*dy)+' '+str(com_exp[i,scom[1]-1-j])+'\n')  
#        outfile2.write(str(i*dx)+' '+str(j*dy)+' '+str(fwhm[i,scom[1]-1-j])+'\n')        
#    
#    for x in com1:
#        outfile3.write(str(x)+'\n')    
#    outfile1.close
#    outfile2.close
#    outfile3.close
  #####################################################################################
  # FIGURES FOR PUBLICATION/SAVE PROCESSED DATA
  #####################################################################################
  com_exp = array(com)-com0
  thmid_exp=array(thmid)-thmid0
  thneg_exp=array(thneg)-thneg0
  thpos_exp=array(thpos)-thpos0
  #--------------------------------------------------------------------------------------------------------------
  if opts.publish==1:
    user_dir = os.getcwd()
    sys.path.append(user_dir)
    from figures import figplot        
    #figplot(opts.transpose,dx,dy,indx1,indx2,indy1,indy2,thmid_exp,fwhm,peak)
    figplot(opts.transpose,dx,dy,indx1,indx2,indy1,indy2,peak,fwhm,stdev,com_exp,thmid_exp,thneg_exp,thpos_exp)
    sys.path.pop()
  ################################################################################################################
  if opts.hdf5 is not None:
    hf = h5py.File(opts.hdf5, 'w')
    hf.attrs['cmd'] = param
    #hf.create_dataset('dx',data = dx)
    #hf.create_dataset('dy',data = dy)
    #hf.create_dataset('indx1',data = indx1)
    #hf.create_dataset('indx2',data = indx2)
    #hf.create_dataset('indy1',data = indy1)
    #hf.create_dataset('indy2',data = indy2)
    #hf.create_dataset('peak',data=array(peak))
    #hf.create_dataset('fwhm',data=array(fwhm))
    #hf.create_dataset('stdev',data=array(stdev))
    #hf.create_dataset('com',data=array(com_exp))
    #hf.create_dataset('thmid',data=array(thmid_exp))
    #hf.create_dataset('thneg',data=array(thneg_exp))
    #hf.create_dataset('thpos',data=array(thpos_exp))
    g1 = hf.create_group("/parameters")    
    g1.create_dataset('dx',data = dx)
    g1.create_dataset('dy',data = dy)
    g1.create_dataset('indx1',data = indx1)
    g1.create_dataset('indx2',data = indx2)
    g1.create_dataset('indy1',data = indy1)
    g1.create_dataset('indy2',data = indy2)
    #-------------------------------------------------------------------------------
    g2 = hf.create_group("/topographs")
    g2.create_dataset('peak',  data=array(peak),  shape=peak.shape,  dtype=float32)
    g2.create_dataset('fwhm',  data=array(fwhm),  shape=fwhm.shape,  dtype=float32)
    g2.create_dataset('stdev', data=array(stdev), shape=stdev.shape, dtype=float32)
    g2.create_dataset('com',   data=array(com),   shape=com.shape,   dtype=float32)
    g2.create_dataset('thmid', data=array(thmid), shape=thmid.shape, dtype=float32)
    g2.create_dataset('thneg', data=array(thneg), shape=thneg.shape, dtype=float32)
    g2.create_dataset('thpos', data=array(thpos), shape=thpos.shape, dtype=float32)
    #--------------------------------------------------------------------------------
    g3 = hf.create_group("/statistics")
    g3.create_dataset('peak0',     data=peak0)
    g3.create_dataset('peak_rms',  data=peak_rms)
    g3.create_dataset('peak_pv',   data=peak_pv)
    g3.create_dataset('fwhm0',     data=fwhm0)
    g3.create_dataset('fwhm_rms',  data=fwhm_rms)
    g3.create_dataset('fwhm_pv',   data=fwhm_pv)
    g3.create_dataset('stdev0',    data=stdev0)
    g3.create_dataset('stdev_rms', data=stdev_rms)
    g3.create_dataset('stdev_pv',  data=stdev_pv)
    g3.create_dataset('com0',      data=com0)
    g3.create_dataset('com_rms',   data=com_rms)
    g3.create_dataset('com_pv',    data=com_pv)
    g3.create_dataset('thmid0',    data=thmid0)
    g3.create_dataset('thmid_rms', data=thmid_rms)
    g3.create_dataset('thmid_pv',  data=thmid_pv)
    g3.create_dataset('thneg0',    data=thneg0)
    g3.create_dataset('thneg_rms', data=thneg_rms)
    g3.create_dataset('thneg_pv',  data=thneg_pv)
    g3.create_dataset('thpos0',    data=thpos0)
    g3.create_dataset('thpos_rms', data=thpos_rms)
    g3.create_dataset('thpos_pv',  data=thpos_pv)
    #---------------------------------------------------------------------------------
    g4 = hf.create_group("/statistics_tot")
    g4.create_dataset('peak_tot',  data=peak_tot)
    g4.create_dataset('fwhm_tot',  data=fwhm_tot)
    g4.create_dataset('stdev_tot', data=stdev_tot)
    g4.create_dataset('com_tot',  data=com_tot)
    g4.create_dataset('thmid_tot',  data=thmid_tot)
    g4.create_dataset('thneg_tot',  data=thneg_tot)
    g4.create_dataset('thpos_tot',  data=thpos_tot)
    #----------------------------------------------------------------------------------    
    hf.close()
  if opts.tif == 1:
    im = Image.fromarray(peak)
    im.save('peak.tif')
    im = Image.fromarray(fwhm)
    im.save('fwhm.tif')
    im = Image.fromarray(stdev)
    im.save('stdev.tif')
    im = Image.fromarray(com)
    im.save('com.tif')
    im = Image.fromarray(thmid)
    im.save('thmid.tif')
    im = Image.fromarray(thneg)
    im.save('thneg.tif')
    im = Image.fromarray(thpos)
    im.save('thpos.tif')    
########################################################################################
## PLOT SLICES AND WRITE FILE
########################################################################################
                 
  if xsl >= 0 or ysl >= 0:    
      
      f3=plt.figure(3)         
      plt.suptitle(sbtitle0+sbtitle, size=20)  
      plt.subplot(331)
      peak_sl_m=np.ma.array(peak_sl,mask=peak_sl>10.0*max(peak1))
      plt.plot(range_sl,peak_sl_m)
      plt.title('Reflectivity',size=ftsize)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(332)
      fwhm_sl_m=np.ma.array(fwhm_sl,mask=fwhm_sl>100.0*fwhm0)
      plt.plot(range_sl,fwhm_sl_m)
      plt.title('FWHM [$\mu$rad]',size=ftsize)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(333)
      stdev_sl_m=np.ma.array(stdev_sl,mask=stdev_sl>100.0*stdev0)
      plt.plot(range_sl,stdev_sl_m)
      plt.title('STDEV [$\mu$rad]',size=ftsize)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(334)
      com_sl_m=np.ma.array(com_sl,mask=com_sl>1.0e6)
      plt.plot(range_sl,com_sl_m)
      plt.title('COM [$\mu$rad]',size=ftsize)
      #plt.xlabel('x [mm]')
      #plt.ylabel('y [mm]')

      plt.subplot(335)
      thmid_sl_m=np.ma.array(thmid_sl,mask=thmid_sl>1.0e6)
      plt.plot(range_sl,thmid_sl_m)
      plt.title('Midpoint [$\mu$rad]',size=ftsize)
      plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')

      plt.subplot(336)
      thneg_sl_m=np.ma.array(thneg_sl,mask=thneg_sl>1.0e6)
      plt.plot(range_sl,thneg_sl_m)
      plt.title('Left Slope [$\mu$rad]',size=ftsize)
      plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')

      plt.subplot(337)
      thpos_sl_m=np.ma.array(thpos_sl,mask=thpos_sl>1.0e6)
      plt.plot(range_sl,thpos_sl_m)
      plt.title('Right Slope [$\mu$rad]',size=ftsize)
      plt.xlabel(str_axis)
      #plt.ylabel('y [mm]')
      
  plt.show() 
  
  if opts.write is not None:
     header = '# '+ str(sys.argv) +'\n' \
            +'# version '+__version__+' by Stanislav Stoupin\n' \
            +'# Slices data\n' \
            +'# columns: \n' \
            '# '+str_axis+' peak(norm) FWHM[urad] COM[urad] mid-point[urad] left-slope[urad] right-slope[urad] STDEV[urad]\n'
     try:                
            writeFile(opts.write,header,range_sl,peak_sl_m,fwhm_sl_m,com_sl_m,thmid_sl_m,thneg_sl_m,thpos_sl_m,stdev_sl_m)
     except IOError as e:
            fatalIOError(e)                                        
                   
if __name__ == '__main__':
        main()                      
