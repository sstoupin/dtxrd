#!/usr/bin/env python

'''
x-ray dynamical diffraction calculator (2-beam approximation)

:author:    Stanislav Stoupin
:email:     sstoupin@gmail.com

:copyright: Copyright 2014 by XSD, Advanced Photon Source, Argonne National Laboratory
:license:   UChicago Argonne, LLC Open Source License, see LICENSE for details.
'''
import os
import sys
from numpy import *
from scipy import *
from pylab import *
import matplotlib as mpl

# TO RUN LOCALLY
#import subprocess
#cmdout=subprocess.getstatusoutput('echo $HOME')
#libpath=cmdout[1]+'/bin/DTXRD/'
#sys.path.append(libpath)
#print "library path: ", libpath
#
#from myio import coljoin, writeFile
#from curvestat import *
#from thfind import *
#from dtxrd0 import *
#from constants import *
#from chi import *
#from deriv import *
#-----------------------------------------------
# TO RUN GLOBALLY
from dtxrd.myio import coljoin, writeFile
from dtxrd.curvestat import *
from dtxrd.thfind import *
from dtxrd.dtxrd0 import *
from dtxrd.constants import *
from dtxrd.chi import *
from dtxrd.deriv import *


prog = os.path.basename(sys.argv[0])
__version__ = '0.51'
#
user_dir = os.getcwd()
mpl.rcParams["savefig.directory"] = os.chdir(user_dir)
#-------------------------------------------------------------------------------------------
# SUMMARY OF CHANGES:
#-------------------------------------------------------------------------------------------
# v 0.11 help page on USAGE extended
# v 0.12 - change name to 2beam
# try to add 2 beam simulation
# v 0.13 basic "engine" for 2beam front surface incidence implemented
# v 0.14 DWF added
# v 0.15
# * anomalous str.f replaced interpolation with spline (see fh.py)
# * compare with Yuri's code - satisfactory so far
# *  spikes ??? divergence for Si? v0.15 - solved by taking f_pp with negative sign (see fh.py) 
# v 0.16
# * centered ranges in accord. with dynamical Bragg law 
# * added crystal thickness to input parameters v0.16 done
# v 0.161 added explicit path to data files (also in fh.py)
# v 0.17 added interpolation of Yuri's tables for f1 and f2 instead of cromer's values at fixed energies
# v 0.18 added energy width for thick non-absorbing crystal
# v 0.19 introduced subroutine dtxrd
# v 0.20 fixed problem with choosing the sign for "coren" in dtxrd
# v 0.21 dth and dE calculated using curvestat/convolution
# v 0.22 added Laue case to dtxrd
# v 0.23 write data to a file (Tplot, Rplot, rc0 (convolution)) 
# v 0.24 added polarization option 
# v 0.25 now using myio stuff to write data
# v 0.26 new functions + include Al2O3
# v 0.27 included calculations of thr and Er
# v 0.28 included warning when expF is small. convolution with res. function is now an option -c
# v 0.29 better understood intrinsic angular dispersion rate - use (2.138) to calculate
#        more precise formula for the angular width in backscattering
# v 0.30 begin to implement calculation of secondary radiation
# v 0.31 secondary electron yield implemented + write SYplot data if -s option is used
# v 0.32 replaced optik with argparse and got rid of "division by zero" in the calculation of Dr
# v 0.33 minor rearrangements of "prog", deleted some obsolete comments
# v 0.34 added RC width for double-crystal symmetric configuration (sqrt(2)*dth_s)
# v 0.35 fixed bug in the range of calculations at fixed angle (center was Eb which is Bragg energy)
#        replaced with Ec (alternative Ex - from kinematic Bragg's law but not Eb definitely)
# v 0.36 zachariasen theory
#        something is wrong with sig_v calculation!
# v 0.37 derived solution to Zachariasen's equations for general asym. case
#        implemented in the code/tested          
# v 0.38 added number of steps in the angular/energy interval as option
#        now can save Rmos1 Tmos1        
# v 0.39 -c res. function now requires an input value (in [urad] for "e" or [meV] for "a")
# v 0.40 model for GaN (wurtzite) 
# v 0.41 model for asym. mosaic Laue/Bragg using Dietrich et al power transfer equations
#        Chang's solutions to equations (book) are likely incorrect
# v 0.42 added backscattering case for moz. crystals - angular dependence very different from E dependence!
# v 0.43 Darwin-Hamilton equations in separate subroutine     darwin_hamilton
#        zero absorption solution also to separate subroutine dtxrd1z
# v 0.44 new format for output of chi.py
#        changed IOError, e: to IOError as e:
# v 0.45 minor changes in output (convolution with instr. function)
# v 0.46 minor changes in output for mosaic crystals, added random dislocation distribution approximation
# v 0.47 minor changes in the output - removed Rmos2, Tmos2 and added Wx and sig
# v 0.48 additional minor changes in the output - introduced total scattering factor SF
# v 0.49 switch Gaussian to Lorentzian in res. function definition (natural tails are Lorentzian in DTXRD)
# v 0.50 cosmetic changes, for consistency with python3
# v 0.51 cosmetic changes to figures
#-------------------------------------------------------------------------------------------------------------
#  things to do
# 1. draw a figure of crystal and waves
# 2. note backscattering for mosaic cr. (e.g., a 90) doesn't work
#    the reflectivity is no longer a smooth function of photon Energy as it breaks at 90 deg
#    need double loop! 


def fatalError(msg):
	sys.stderr.write('Error: ')
	sys.stderr.write(str(msg))
	sys.stderr.write('\n')
	sys.exit(1)

def fatalIOError(err):
	if issubclass(err.__class__, IOError) and err.strerror and err.filename:
		err = '%s: %s' % (err.strerror, err.filename)
	fatalError(err)

def ParseArguments():
        import argparse   # requires Python 2.7 or higher
        msg = prog + '  version: ' + __version__ + '\n'*2 + __doc__.strip()+'\n'
#        msg0 =  prog +' [OPTIONS...] crystal h k l eta phi T d flag Ex(or theta) \n'+'where:\n'
        msg1 = 'available crystal models: C(diamond), Si, Ge, GaN(wurtzite), FeS2, SiC-4H, SiC-6H, Al2O3, SiO2\n' 
        msg2 = 'Miller index\n' 
        msg3 = 'asymmetry angle [deg] \n' 
        msg4 = 'azimuthal angle of incidence [deg]\n' 
        msg5 = 'temperature [K] \n' 
        msg6 = 'crystal thickness [mm] \n'
        msg7 = 'flag = a  # calculate at a fixed angle of incidence\n' \
             + 'flag = e  # calculate at a fixed x-ray photon energy\n' 
        msg8 = 'th - angle of incidence [deg] (if flag = a) \n' \
             + 'Ex - x-ray photon energy [keV] (if flag = e)'	
        #        	
        parser = argparse.ArgumentParser(prog=prog, description=msg, formatter_class = argparse.RawDescriptionHelpFormatter)
#------------------------------------------------------------------------------------------------------------------------------
        parser.add_argument('-v', '--version', action='version', version=__version__)
#----------------------------------------------------------------------------------------------
        parser.add_argument('-o', '--output', action='store', dest='output', default=None, metavar='F',
                help='write calculated parameters to file F (defaults to stdout)')
        parser.add_argument('-w', '--write', action='store', dest='write', default=None, metavar='D',
                help='write data to file D (default: do not write)')
        parser.add_argument('-p', '--pi', action='store_const', const=1, dest='polarization', default=0,  
                help='pi polarization of the incident wave (default: s-polarization)')	
        parser.add_argument('-c', '--conv', action='store', dest='conv', default=0,  
                help='convolve with instrumental resolution function of specified width ([urad] or [meV]) and plot result')	                                
        parser.add_argument('-s', '--syield', action='store', dest='syield', default=-1, metavar='Ls',
                help='calculate secondary radiation yield with escape length Ls [Angstrom]')
        parser.add_argument('-z','--zblock', action='store', dest='z', default='-1 -1', metavar='Z',  
                help='Z = \'t s\', where t is thickness [um] and s misorientation [urad] of mosaic crystal blocks (uncorrelated block model, Darwin-Hamilton Eq.)')
        parser.add_argument('-n', '--nsteps', action='store', dest='ns', default=1000, metavar='NS',  
                help='NS - number of points in the angular/energy interval (default NS=1000)')
#-----------------------------------------------------------------------------------------------
        parser.add_argument('crystal', action='store', nargs=1, help=msg1)
        parser.add_argument('h', action='store', type=float, nargs=1, help=msg2)
        parser.add_argument('k', action='store', type=float, nargs=1, help=msg2)
        parser.add_argument('l', action='store', type=float, nargs=1, help=msg2)
#
        parser.add_argument('eta', action='store', type=float, nargs=1, help=msg3)
        parser.add_argument('phi', action='store', type=float, nargs=1, help=msg4)
        parser.add_argument('T', action='store', type=float, nargs=1, help=msg5)
        parser.add_argument('d', action='store', type=float, nargs=1, help=msg6)
        parser.add_argument('flag', action='store', nargs=1, help=msg7)
        parser.add_argument('th_Ex', action='store', type=float, nargs=1, help=msg8)        
        #
        return parser.parse_args()
#-----------------------------------------------------------------------------------------------
def main():
        cmd_opts = ParseArguments()
                
        if cmd_opts.output is not None:
               try:
                        outFile = open(cmd_opts.output, 'w')
               except IOError as e:
                        fatalIOError(e)
        else:
                outFile = sys.stdout
########
        h = cmd_opts.h[0]          #float(args[1])
        k = cmd_opts.k[0]          #float(args[2])
        l = cmd_opts.l[0]          #float(args[3])
        eta = cmd_opts.eta[0]/r2d    #float(args[4])/r2d  #; print "cos(eta) =", cos(eta)
        phi = cmd_opts.phi[0]/r2d    #float(args[5])/r2d
        T = cmd_opts.T[0]          #float(args[6])
        dc = 1.0e7*cmd_opts.d[0]   #1.0e7*float(args[7]) # [A] crystal thickness
        flag = cmd_opts.flag[0]    #args[8]
######## polarization factor ############################################################################
        P=1.0   # default value (sigma) - if pi - controlled by option -p
        nsteps = float(cmd_opts.ns)
######################################################################################################### 
## LATTICE PARAMETER AND BRAGG ENERGY
#########################################################################################################  
        crystal,flagFh=chi(cmd_opts.crystal[0],h,k,l,T,5.0e4)        
        # break if structure amplitude is too small:
        if flagFh==0: 
           fatalError('forbidden reflection: structure amplitude |exp(iHr)| for the chosen set of Miller indicies is too small (< 1e-6)')
        #------------------------------------------------------------------------------------                                                          
        dh=crystal[1]
        Eb=0.5*hpl*cl/dh
        thr,Er=thr_find(cmd_opts.crystal[0],h,k,l,eta,phi,T,dc,Eb) 
######  BEGIN OUTPUT ###############################################################################
        outFile.write('##############################################################\n')
        outFile.write('##### ' + prog + ' v'+__version__+' ############################################\n')
        outFile.write('##### Author: Stanislav Stoupin ## sstoupin@gmail.com ######\n')
        outFile.write('##############################################################\n')
        outFile.write('PARAMETERS OF THE H K L REFLECTION :\n')
#        outFile.write('a [A] = '+str(a)+' lattice parameter\n')	
        outFile.write('d [A] = '+str(dh)+' d-spacing\n')	
        outFile.write('Eb [keV]  = '+str(1.0e-3*Eb)+' Bragg Energy\n')
        outFile.write('thr [deg] = '+str(thr*r2d)+' Angle of the exact backscattering\n')
        outFile.write('Er [keV] = '+str(1.0e-3*Er)+' Energy of the exact backscattering\n')
        outFile.write('--------------------------------------------------------------\n')        
####################################################################################################         
        # VECTOR Z (depth) for calculations of the field inside the crystal
        # performed together with secondary yield calculations
        ############################################################################################
        if cmd_opts.syield!=-1:
            Ls=float(cmd_opts.syield)
            if Ls < dc/3.0:
                zran=3.0*Ls
            else:
                zran=dc
            zstep=zran/float(200)
            #zv = arange(0.0,zran,zstep)            
            zv = arange(0.0,zran+zstep,zstep) #; print "zv = ", zv
        ############################################################################################
        # Darwin model of mosaic crystal
        ############################################################################################
        mosaic = cmd_opts.z.split(' ')
        t0 = 1.0e4*float(mosaic[0])  # [Angstrom]
        Del0 = 1.0e-6*float(mosaic[1])      # [rad]                
        #############################################################################################
        # CALCULATIONS AT FIXED GLANCING ANGLE OF INCIDENCE
        #############################################################################################
        if flag=='a':
             thb=cmd_opts.th_Ex[0]/r2d
             thc=thb        # assume input angle as true central angle
             Ex=Eb/sin(thb) # approximate energy from kinematic Braggs Law
             # take polarization into account:                          
             if cmd_opts.polarization==1:
                P=cos(2.0*thc)             
#             print "Ex = ", Ex
             crystal,flagFh=chi(cmd_opts.crystal[0],h,k,l,T,Ex)
             result0=dtxrd1(thc,eta,phi,dc,Ex,P,crystal) # first iteration to find wh
             wh=result0[1]
             Ec=Eb*(1.0+wh)/sin(thc) # found center energy Ec            
#             print "Ec = ", Ec
             crystal,flagFh=chi(cmd_opts.crystal[0],h,k,l,T,Ec)
             result0=dtxrd1(thc,eta,phi,dc,Ec,P,crystal) # second iteration to find wh
             wh=result0[1]
             Ec=Eb*(1.0+wh)/sin(thc) # found center energy Ec            
#             print "Ec = ", Ec
             # now determine constants at Ec, thc
             crystal,flagFh=chi(cmd_opts.crystal[0],h,k,l,T,Ec)
             [[Chi0,Chih,Chih_],dh,lp,ang]=crystal
             #
             lamc=hpl*cl/Ec
             K0=2.0*pi/lamc   # ; print "K0 = ", K0
             H0=2.0*pi/dh     # ; print "H0 = ", H0
             #
             G0=cos(thc)*sin(eta)*cos(phi)+sin(thb)*cos(eta)
             Gh=G0-H0/K0*cos(eta)
             bh=G0/Gh              
             ##############################################################################
             if cmd_opts.syield ==-1:
                 [wh_s,wh,ep,dt,de,Tc,Rc]=dtxrd1(thc,eta,phi,dc,Ec,P,crystal)                                       
             else:
                 # display distribution of field intensity in the crystal along z
                 f2=plt.figure()
                 [[wh_s,wh,ep,dt,de,Tc,Rc],[GG,DD]] = dtxrd1_D0Dh(thc,eta,phi,dc,Ec,P,crystal,zv)
                 G0=GG[0]; Gh=GG[1]
                 D0=DD[0]; Dh=DD[1]             #; print "Dh = ", Dh     
                 D02=abs(D0)**2.0; [zz,dD02]=deriv(zv,D02)
                 Dh2=abs(Dh)**2.0; [zz,dDh2]=deriv(zv,Dh2) #; print "dDh2 = ", dDh2
                 kappaz=-G0*dD02+abs(Gh)*dDh2   #; print "kappaz = ", kappaz # total x-ray absorption in dz
                 Pz=exp(-zz/Ls)                 # probability of secondary emission from dz
                 syieldz=array(kappaz)*array(Pz)  #; print "syieldz = ", syieldz
                 syield_tot=zstep*sum(syieldz)    #; print "syield_tot = ", syield_tot
                 plt.plot(zv, D02, label='abs(D0)^2')
                 plt.plot(zv, Dh2, label='abs(Dh)^2')                 
#                 plt.plot(1.0e-7*zz, dD02, label='d abs(D0)^2/dz')
#                 plt.plot(1.0e-7*zz, dDh2, label='d abs(Dh)^2/dz')
#                 plt.plot(1.0e-7*zz, kappaz, label='kappaz')
#                 plt.plot(1.0e-7*zz, Pz, label='Pz')
#                 plt.plot(1.0e-7*zz, syieldz, label='syieldz')                 
                 plt.ylabel('Field intensity inside the crystal [n.u.]')
                 plt.xlabel('z [$\\AA$]')
                 plt.legend(loc='lower right')
             ###############################################################################    
             [eps_s,eps,eps_pr]=ep
             [dth_s,dth,dth_pr]=dt
             ###############################################################################
             ###############################################################################
             # 
             bth = abs(0.5*pi-thb)
             omeg0=2.0*sqrt(eps_s)
             if cmd_opts.z != '-1 -1':
                if bth < omeg0:
                    th1 = -3.0*dth
                    #th1 = -1*Del0
                    th2 =  3.0*dth
                    #th2 = 1*Del0
                else: 
                    th1=-10.0*Del0  # rad
                    th2=10.0*Del0   # rad
                thstep= (th2-th1)/nsteps # rad  ### need more steps
                th_e=thc+arange(th1,th2,thstep)
                
                if bth < omeg0:  # close-to backscattering
                    #Ex_v = Ec - Ec*(th_e-thc)*(1.0 - 0.5*bth**2.0) # (-) because of diff. Bragg's law, incorrect!
                    Ex_v = Ec - Er*(th_e-thc)*(0.5*pi - thc) ## need to think how to 
                    #Ex_v = Er*(1.0 + 0.5*(0.5*pi - th_e)**2.0)                     
                else:
                    Ex_v = Ec - Ec*(th_e-thc)/tan(thc)
             else: 
                 DelE = eps*Ec
                 E1 = -10.0*DelE  
                 E2 = 10.0*DelE
                 Estep=(E2-E1)/nsteps # eV
                 Ex_v=Ec+arange(E1,E2,Estep)
             ############################################################################################
             # Perfect crystal reflectivity/transmissivity and secondary yield
             ###########################################################################################             
             Tplot=[]; Rplot=[]; SYplot=[]
             if cmd_opts.syield == -1:  
                 for Ex in Ex_v:
                     result2=dtxrd1(thc,eta,phi,dc,Ex,P,crystal) # now calculate transmissivity/reflectivity                  
                     Tplot=Tplot+[result2[5]]; Rplot=Rplot+[result2[6]]
             else:
                 for Ex in Ex_v:                     
                     result2=dtxrd1_sy(thc,eta,phi,dc,Ex,P,crystal,Ls)
                     Tplot=Tplot+[result2[5]]; Rplot=Rplot+[result2[6]]
                     SYplot=SYplot+[result2[7]]
###          ######################################################################################
###          # IF Mosaic crystal ##################################################################
###          ######################################################################################
             if cmd_opts.z != '-1 -1': 
                 #
                 Wx_v = exp(-(th_e - thc)**2.0/(2.0*Del0**2.0))                                  
                 Norm = sum(Wx_v)
                 Wx_v = Wx_v/Norm
                 #                                  
                 Tplot0 = []; Rplot0 = []
                 Tplot0z = []; Rplot0z = []                                  
                 for thx in th_e: # this is to calculate reflectivities as function of angle distribution of subdomains thx
                     result3=dtxrd1(thx,eta,phi,t0,Ec,P,crystal)  # non-zero absorption
                     result4=dtxrd1z(thx,eta,phi,t0,Ec,P,crystal) # zero absorption solution                
                     #
                     Tplot0=Tplot0+[result3[5]]; Rplot0=Rplot0+[result3[6]]                     
                     Tplot0z=Tplot0z+[result4[5]]; Rplot0z=Rplot0z+[result4[6]]                                                               
                     #
                 Tplot0 = array(Tplot0); Rplot0 = array(Rplot0)   
                 Tplot0z = array(Tplot0z); Rplot0z = array(Rplot0z)
                 #
                 sig_v = 1.0/t0*convolve(Rplot0,Wx_v,'same')   # non-zero absorption 
                 sig_vz = 1.0/t0*convolve(Rplot0z,Wx_v,'same') # zero absorption
                 # this convoluted sig_v represents reflectivity as function of incident angle on the crystal
                 # but through the Bragg's law can be converted to reflectivity as function of inc. photon energy
                 ######################################################################################################
                 stuff1 = darwin_hamilton(thc,eta,phi,dc,Ec,P,crystal,sig_vz)                                          
                 Tpmos = stuff1[3]; Rpmos = stuff1[4]
                 Tmos1 = stuff1[5]; Rmos1 = stuff1[6];                                     
                 A = stuff1[0]; Gs_mu = stuff1[1]; opt_d = stuff1[2]
                 #
                 stat1 = curvestat(Ex_v,Rmos1,0.0)
                 rmax_mos1 = stat1[1]
                 fwhm_mos1 = stat1[5]
                 #
                 ##stuff2 = darwin_hamilton(thc,eta,phi,dc,Ec,P,crystal,sig_v)                                          
                 #Tpmos = stuff2[3]; Rpmos = stuff1[4]; 
                 ##Tmos2 = stuff2[5]; Rmos2 = stuff2[6]
                 SF = sig_vz*dc/G0*(1.0+bh) # Total scattering factor
             ######################################################################################  
             # convolution to calculate FWHM for the refl. curve
             ######################################################################################
             if cmd_opts.conv != 0:
                fwhm0 = 1.0e-3*float(cmd_opts.conv) # FWHM [meV] estimate for instrument resolution function
                bw=0.5*fwhm0; b=[0.0,1.0,Ec,bw]; rf=lorentz(b,Ex_v)               # Lorentzian
                #bw = 0.5*fwhm0/sqrt(log(2.0)); b=[0.0,1.0,Ec,bw]; rf=gauss(b,Ex_v)   # Gaussian
                rf = rf/sum(rf)
                rc0 = convolve(Rplot,rf,'same')
                stat0 = curvestat(Ex_v,rc0,0.0)
                rmax_ex = stat0[1]
                fwhm_ex = stat0[5]
             else: 
                rc0 = zeros(len(Rplot))
             ######################################################################################
             # PLOT RESULTS                               
             ######################################################################################
             Eplot=1.0e3*(Ex_v-Ec) # meV      
             #print "len(Eplot)", len(Eplot)
             outx0=1.0e-3*Ex_v     # keV
             outx1=Eplot           # meV  
             outh0='E[keV] '       # header_col0
             outh1='E-Ec[meV] '    # header_col1
             
             #f2 = plt.figure()                                      
             if cmd_opts.syield != -1:
                 f2 = plt.figure(figsize=(6,8))
                 plt.subplot(311)
                 plt.plot(Eplot,Rplot,'r-')
                 if cmd_opts.conv !=0: plt.plot(Eplot,rc0,'k-')
                 #                 
                 plt.ylabel('Reflectivity')
                 #
                 plt.subplot(312)
                 plt.plot(Eplot,Tplot,'b-')
                 plt.ylabel('Transmissivity')
                 #plt.xlabel('$E-E_{c}$ [meV]')
                 #
                 plt.subplot(313)
                 plt.plot(Eplot,SYplot/max(SYplot),'g-')
                 plt.ylabel('Secondary yield [n.u.]')
                 plt.xlabel('$E-E_{c}$ [meV]')
             else:
                 f2 = plt.figure(figsize=(6,6))
                 SYplot=zeros(len(Rplot))
                 plt.subplot(211)
                 plt.plot(Eplot,Rplot,'r-',label='$R_{perfect}(E -E_{c})$')
                 if cmd_opts.conv != 0: plt.plot(Eplot,rc0,'k-')
                 if cmd_opts.z != '-1 -1': 
                     #plt.plot(Eplot,Rpmos,'c-',label='$R_{ideal \ mos.}(E-E_{c})$')
                     #plt.plot(Eplot,Rmos1,'m--',label='$R_{mos.1 \ (zero \ abs.) \ asym.}(E-E_{c})$')
                     plt.plot(Eplot,Rmos1,'m--',label='$R_{mosaic}(E-E_{c})$')
                     #plt.plot(Eplot,Rmos2,'g--',label='$R_{mos.2 \ (non-zero \ abs.}(E-E_{c})$')
                     #plt.plot(Eplot,Rpmos,'g-',label='$R_{pmosaic}(E-E_{c})$')
                     plt.plot(Eplot,Wx_v*Norm,'k-',label='$W(E-E_{c})$')
                     #
                     #plt.plot(Eplot,t0*sig_vz,'m-',label='$t_0 \\times \\sigma_z(E-E_{c})$')
                     #plt.plot(Eplot,t0*sig_v,'g-',label='$t_0 \\times \\sigma(E-E_{c})$')
                     ##plt.plot(Eplot,SF,'m-',label='$T_0(1.0+b_H)/\\gamma_0 \\sigma_z(E-E_{c})$')  # plot total scattering factor
                     #plt.plot(Eplot,sig_v/max(sig_v),'g-',label='$\\sigma(E-E_{c})$ [n.u.]')
                     #
                     plt.legend(loc='upper right')
                 plt.ylabel('Reflectivity')
                 #
                 plt.subplot(212)
                 plt.plot(Eplot,Tplot,'b-', label='$T_{perfect}(E-E_{c})$')
                 if cmd_opts.z != '-1 -1':
                     #plt.plot(Eplot,Tpmos, 'c-',  label='$T_{ideal mos.}(E-E_{c})$')
                     #plt.plot(Eplot,Tmos1,'m--', label='$T_{mos.1 (zero \ abs.) asym.}(E-E_{c})$')
                     plt.plot(Eplot,Tmos1,'m--', label='$T_{mosaic}(E-E_{c})$')
                     #plt.plot(Eplot,Tmos2,'g--', label='$T_{mos.2 (non-zero \ abs.)}(E-E_{c})$')
                     plt.legend(loc='upper right') 
                 #                                          
                 plt.ylabel('Transmissivity')
                 plt.xlabel('$E-E_{c}$ [meV]')
        ###########################################################################################
        # CALCULATIONS AT FIXED PHOTON ENERGY
        ###########################################################################################
        elif flag=='e':
             Ex=1.0e3*cmd_opts.th_Ex[0]
             Ec=Ex       # assume input energy as true central energy
             if Ex<Eb:
                  fatalError('Ex must be greater than Eb')
             else:
                  thb=arcsin(Eb/Ex)  # approximate angle from kinematic Braggs Law
                  outFile.write('thb [deg] = '+str(r2d*thb)+' Bragg angle\n') 
     
             if cmd_opts.polarization==1:
                P=cos(2.0*thb)                               
             crystal,flagFh=chi(cmd_opts.crystal[0],h,k,l,T,Ec)
             result0=dtxrd1(thb,eta,phi,dc,Ec,P,crystal) # first iteration to find wh
             wh=result0[1]                                                    
             thc=arcsin((Eb/Ec)*(1.0+wh))        # determine central angle

             if cmd_opts.polarization==1:
                P=cos(2.0*thc)
             result0=dtxrd1(thc,eta,phi,dc,Ec,P,crystal) # second iteration to find wh
             wh=result0[1]                     
             thc=arcsin((Eb/Ec)*(1.0+wh))        # determine central angle
             #
             if cmd_opts.polarization==1:
                P=cos(2.0*thc)
             # calculate constants at thc,Ec
             [[Chi0,Chih,Chih_],dh,lp,ang]=crystal
             ################################################################
             # determine direction cosines, asym. ratio
             lamc=hpl*cl/Ec
             K0=2.0*pi/lamc   # ; print "K0 = ", K0
             H0=2.0*pi/dh     # ; print "H0 = ", H0
             #
             G0=cos(thc)*sin(eta)*cos(phi)+sin(thb)*cos(eta)
             Gh=G0-H0/K0*cos(eta)
             bh=G0/Gh 
             ###############################################################                                       
             if cmd_opts.syield ==-1:
                 [wh_s,wh,ep,dt,de,Tc,Rc]=dtxrd1(thc,eta,phi,dc,Ec,P,crystal)
             else:
                 # display distribution of field intensity in the crystal along z
                 f2=plt.figure()
                 [[wh_s,wh,ep,dt,de,Tc,Rc],[GG,DD]] = dtxrd1_D0Dh(thc,eta,phi,dc,Ec,P,crystal,zv)
                 G0=GG[0]; Gh=GG[1]
                 D0=DD[0]; Dh=DD[1]  #;print "Dh = ", Dh     
                 D02=abs(D0)**2.0; [zz,dD02]=deriv(zv,D02)
                 Dh2=abs(Dh)**2.0; [zz,dDh2]=deriv(zv,Dh2) #; print "dDh2 = ", dDh2
                 kappaz=-G0*dD02+abs(Gh)*dDh2   #; print "kappaz = ", kappaz # total x-ray absorption in dz
                 Pz=exp(-zz/Ls)                 # probability of secondary emission from dz
                 syieldz=array(kappaz)*array(Pz)  #; print "syieldz = ", syieldz
                 syield_tot=zstep*sum(syieldz)    #; print "syield_tot = ", syield_tot
                 plt.plot(zv, D02, label='abs(D0)^2')
                 plt.plot(zv, Dh2, label='abs(Dh)^2')                 
#                 plt.plot(1.0e-7*zz, dD02, label='d abs(D0)^2/dz')
#                 plt.plot(1.0e-7*zz, dDh2, label='d abs(Dh)^2/dz')
#                 plt.plot(1.0e-7*zz, kappaz, label='kappaz')
#                 plt.plot(1.0e-7*zz, Pz, label='Pz')
#                 plt.plot(1.0e-7*zz, syieldz, label='syieldz')                 
                 plt.ylabel('Field intensity inside the crystal [n.u.]')
                 plt.xlabel('z [$\\AA$]')
                 plt.legend(loc='upper right')
             #################################################                                                               
             [eps_s,eps,eps_pr]=ep
             [dth_s,dth,dth_pr]=dt
             # thc - final iteration
             thc=arcsin((Eb/Ec)*(1.0+wh))                                                                 
             #################################################
             #################################################
             if cmd_opts.z != '-1 -1' and Del0 > dth/2.35:                
                 th1 = -20.0*Del0
                 th2 = 20.0*Del0
                 thstep=(th2-th1)/nsteps
             else:             
                 th1=-10.0*dth  # rad
                 th2=10.0*dth   # rad
                 thstep= (th2-th1)/nsteps # rad
             #################################################
             thb_v=thc+arange(th1,th2,thstep)  # create vector of angles
             #             
             Tplot=[]; Rplot=[]; SYplot=[]             
             for thx in thb_v:
                 if cmd_opts.polarization == 1:  # this is likely overkill - for P thx is thc
                    P=cos(2.0*thx)                           
                 if cmd_opts.syield == -1:
                     result2=dtxrd1(thx,eta,phi,dc,Ec,P,crystal)  # now calculate transmissivity/reflectivity  
                     Tplot=Tplot+[result2[5]]; Rplot=Rplot+[result2[6]]
                 else: 
                     result2=dtxrd1_sy(thx,eta,phi,dc,Ec,P,crystal,Ls) 
                     Tplot=Tplot+[result2[5]]; Rplot=Rplot+[result2[6]] 
                     SYplot=SYplot+[result2[7]] 
###          ######################################################################################                             
###          ######################################################################################
###          # IF Mosaic crystal ##################################################################
###          ######################################################################################
             if cmd_opts.z != '-1 -1': 
                #################################################
                 Wx_v = exp(-(thb_v - thc)**2.0/(2.0*Del0**2.0))                 
                 Norm = sum(Wx_v)
                 Wx_v = Wx_v/Norm                 
                 ############################################################
                 ## but it is really just a convolution!                 
                 ## and Rplot must be that of a single block t0-thick!!!
                 ############################################################
                 Tplot0=[]; Rplot0=[]
                 Tplot0z=[]; Rplot0z=[]
                 for thx in thb_v:
                     result3=dtxrd1(thx,eta,phi,t0,Ec,P,crystal)
                     result4=dtxrd1z(thx,eta,phi,t0,Ec,P,crystal) # zero absorption solution                
                     #
                     Tplot0=Tplot0+[result3[5]]; Rplot0=Rplot0+[result3[6]]                     
                     Tplot0z=Tplot0z+[result4[5]]; Rplot0z=Rplot0z+[result4[6]]                                                               
                     #
                 Tplot0 = array(Tplot0); Rplot0 = array(Rplot0)   
                 Tplot0z = array(Tplot0z); Rplot0z = array(Rplot0z)	
                 #
                 sig_v = 1.0/t0*convolve(Rplot0,Wx_v,'same')
                 sig_vz = 1.0/t0*convolve(Rplot0z,Wx_v,'same')                  
                 ############################################################################
                 ## calculate parameters at fixed thc
                 ## angular dependence is in sig_v, other functions are flat around thc
                 ############################################################################
                 stuff1 = darwin_hamilton(thc,eta,phi,dc,Ec,P,crystal,sig_vz)                                          
                 Tpmos = stuff1[3]; Rpmos = stuff1[4]
                 Tmos1 = stuff1[5]; Rmos1 = stuff1[6];                                     
                 A = stuff1[0]; Gs_mu = stuff1[1]; opt_d = stuff1[2]
                 #
                 stat1 = curvestat(thb_v,Rmos1,0.0)
                 rmax_mos1 = stat1[1]
                 fwhm_mos1 = stat1[5]
                 #
                 ##stuff2 = darwin_hamilton(thc,eta,phi,dc,Ec,P,crystal,sig_v)                                          
                 #Tpmos = stuff2[3]; Rpmos = stuff1[4]; 
                 ##Tmos2 = stuff2[5]; Rmos2 = stuff2[6];                                      
                 SF = sig_vz*dc/G0*(1.0+bh) # Total scattering factor 
             ########################################################################################### 
             ###########################################################################################
             # convolution to calculate FWHM
             ###########################################################################################
             if cmd_opts.conv != 0:
                fwhm0 = 1.0e-6*float(cmd_opts.conv)  # FWHM [urad] estimate for instrument resolution function
                bw=0.5*fwhm0; b=[0.0,1.0,thc,bw]; rf=lorentz(b,thb_v) 		# Lorentzian
                #bw = 0.5*fwhm0/sqrt(log(2.0)); b=[0.0,1.0,thc,bw]; rf=gauss(b,thb_v)   # Gaussian
                rf = rf/sum(rf)                                   
                rc0 = convolve(Rplot,rf,'same')
                stat0 = curvestat(thb_v,rc0,0.0)
                rmax_th = stat0[1]
                fwhm_th = stat0[5]
             else: rc0=zeros(len(Rplot))                          
             ###########################################################################################
             # PLOT RESULTS
             ########################################################################################### 
             thplot=1.0e6*(thb_v-thc) # urad             
             outx0=thb_v*r2d          # deg
             outx1=thplot             # urad
             outh0='th[deg] '         # header_col0
             outh1='th-thc[urad] '    # header_col1
             #
             #f1=plt.figure(figsize=(6,6))
             #plt.xlabel('theta-theta0 [urad]')
             #plt.axis([1.0e6*th1,1.0e6*th2,0,auto])
             #
             if cmd_opts.syield != -1:
                 f1=plt.figure(figsize=(6,8))
                 plt.subplot(311)
                 plt.plot(thplot,Rplot,'r-')
                 if cmd_opts.conv != 0: plt.plot(thplot,rc0,'k-')                        
                 plt.ylabel('Reflectivity')
                 #plt.axis([1.0e6*th1,1.0e6*th2,0,2])
                 plt.subplot(312)
                 plt.plot(thplot,Tplot,'b-')
                 plt.ylabel('Transmissivity')
                 plt.subplot(313)
                 plt.plot(thplot,SYplot/max(SYplot),'g-')
                 plt.ylabel('Secondary yield [n.u.]')
                 plt.xlabel('$\\theta-\\theta_{c}$ [$\mu$rad]')
             else: 
                 f1=plt.figure(figsize=(6,6))
                 SYplot=zeros(len(Rplot))
                 plt.subplot(211)
                 plt.plot(thplot,Rplot,'r-', label='$R_{perfect}(\\theta-\\theta_{c})$')
                 if cmd_opts.conv != 0: plt.plot(thplot,rc0,'k-')                        
                 if cmd_opts.z != '-1 -1': 
                     #plt.plot(thplot,Rpmos,'c-',     label='$R_{ideal \ mos.}(\\theta-\\theta_{c})$')
                     #plt.plot(thplot,Rmos1,'m--',   label='$R_{mos.1 \ zero \ abs.}(\\theta-\\theta_{c})$')
                     plt.plot(thplot,Rmos1,'m--',   label='$R_{mosaic}(\\theta-\\theta_{c})$')   
                     #plt.plot(thplot,Rmos2,'g--',   label='$R_{mos.2 \ non-zero \ abs.}(\\theta-\\theta_{c})$')
                     #plt.plot(thplot,Rpmos,'g-',    label='$R_{pmosaic}(\\theta-\\theta_{c})$')                     
                     #
                     plt.plot(thplot,Wx_v*Norm,'k-',label='$W(\\theta-\\theta_{c})$')
                     #
                     ##plt.plot(thplot,SF,'m-',label='$T_0(1+b_H)/\\gamma_0 \\times \\sigma_z(\\theta-\\theta_{c})$')
                     #plt.plot(thplot,t0*sig_v,'g-',label='$t_0 \\times \\sigma(\\theta-\\theta_{c})$')
                     #plt.plot(thplot,sig_vz/max(sig_vz),'m-',label='$\\sigma_z(\\theta-\\theta_{c})$ [n.u.]')
                     #plt.plot(thplot,sig_v/max(sig_v),'g-',label='$\\sigma(\\theta-\\theta_{c})$ [n.u.]')
                     #
                     plt.legend(loc='upper right')
                 plt.ylabel('Reflectivity')
                 plt.subplot(212)
                 plt.plot(thplot,Tplot,'b-', label='$T_{perfect}(\\theta-\\theta_{c})$')
                 if cmd_opts.z != '-1 -1':
                     #plt.plot(thplot,Tpmos, 'c-',  label='$T_{mos. \ sym.}(\\theta-\\theta_{c})$')
                     #plt.plot(thplot,Tmos1,'m--', label='$T_{mos.1 \ zero \ abs.}(\\theta-\\theta_{c})$')
                     plt.plot(thplot,Tmos1,'m--', label='$T_{mosaic}(\\theta-\\theta_{c})$')
                     #plt.plot(thplot,Tmos2,'g--', label='$T_{mos.2 \ non-zero \ abs.}(\\theta-\\theta_{c})$')
                     plt.legend(loc='upper right')
                 plt.ylabel('Transmissivity')
                 plt.xlabel('$\\theta-\\theta_{c}$ [$\mu$rad]')
#
        else: fatalError('flag arg[8] either a (angle) or e (energy)')

###############################################################################
####### CONTINUE OUTPUT
###############################################################################	
        #######################################################################
        # integrated reflectivities: perfect crystal and mosaic crystal
        #######################################################################    
        Ri_int = sum(Rplot)   # need to divide by N for normalization purposes
        if cmd_opts.z != '-1 -1': 
            Rpmos_int = sum(Rpmos)  # but since N is the same omit                                                      
            Rmos1_int = sum(Rmos1) # for asym. case #1 (incorrect formulas)
            #Rmos2_int = sum(Rmos2) # for asym. case #2
            # average size of mosaic blocks
            # random dislocation distribution approximation
            # assume Burgers vector equal to lp
            # Del0 in rad, lp in Angstrom
            burg = sqrt(2.0)/2.0*array(lp)*1.0e-4 # to microns, here assume b = a/2*sqrt(1^2+1^2+0^2)
            #msize = 0.5*burg*sqrt(pi)/(Del0) # grain - subgrain model Duhn & Koch
            msize = burg/(Del0*2.0*sqrt(2.0*log(2.0)))
            ###################################################################            
        #----------------------------------------------------------------------
        #G0=cos(thc)*sin(eta)*cos(phi)+sin(thb)*cos(eta)
        #Gh=G0-2.0*sin(thb)*cos(eta)
        #bh=G0/Gh 
        #       
        ## Calculate dispersion rate #################
        #Dr=2.0e3*sin(thc)*sin(eta)/(Ec*sin(thc-eta)) #murad/meV
        eps_eta = 1.0e-7
        Dr=-2.0e3/(cos(phi)/tan(thc)-1.0/tan(eta+eps_eta))/Ec # now using (2.138)
        # notes:
        # this is angular dispersion rate in the dispersion plane
        # for phi=0 and phi=180 represents variation of dth_pr
        # it can't be maximized by choice of phi=90 since eta < thc
        # i.e. cot(eta) is always greater than cot(thc)
        #                                           
        outFile.write('bh = '+str(bh)+' asymmetry factor\n')
        outFile.write('G0 = '+str(G0)+' direction cosine of the incident wave\n')
        outFile.write('Gh = '+str(Gh)+' direction cosine of the reflected wave\n')
        outFile.write('##############################################################\n')
        outFile.write('# DYNAMICAL THEORY: \n')
        outFile.write('##############################################################\n')
        outFile.write('# Susceptibilities and Refraction Corrections: \n')
        outFile.write('chi_{0}  = ' +str(Chi0)+  '\n')
        outFile.write('chi_{h}  = ' +str(Chih)+  '\n')
        outFile.write('chi_{-h} = '+str(Chih_)+ '\n')
        outFile.write('wh(s) = '+str(wh_s)+  '\n')
        outFile.write('wh    = '+str(wh)+    '\n')
        outFile.write('#-------------------------------------------------------------\n')
        outFile.write('# Central Energy/Angle: \n')        
        outFile.write('Ec [keV]  = '+str(1.0e-3*Ec)+'\n')                                       
        outFile.write('thc [deg] = '+str(thc*r2d)+'\n') 
        outFile.write('#-------------------------------------------------------------\n')                
        outFile.write('# Energy and Angular Intriscis Widths (thick non-absorbing crystal):\n')        
        outFile.write('eps_s  = ' +str(eps_s)+ '\n')
        outFile.write('eps    = ' +str(eps)+   '\n')
        outFile.write('eps_pr = ' +str(eps_pr)+'\n')
        outFile.write('Delta_E_s [meV]    = '+str(1.0e3*Ec*eps_s)+' \n')
        outFile.write('Delta_E [meV]    = '+str(1.0e3*Ec*eps)+' \n')        
        outFile.write('Delta_E_pr [meV] = '+str(1.0e3*Ec*eps_pr)+' \n')
        outFile.write('dth_s [urad]  = '+str(1.0e6*dth_s)+ '\n')
        outFile.write('dth   [urad]  = '+str(1.0e6*dth)+   '\n')
        outFile.write('dth_pr [urad] = '+str(1.0e6*dth_pr)+ '\n')
        outFile.write('#-------------------------------------------------------------\n')
        outFile.write('# Additional Characteristics of the Reflection: \n')
        outFile.write('dE/dth [meV/urad] = '+str(1.0e-3*Ec/tan(thc))+' Tangent of the Braggs Law \n') 
        outFile.write('Dr [urad/meV] = '+str(Dr)+' Intrinsic Angular Dispersion Rate \n') 
        outFile.write('de [um] = '+str(1.0e-4*de)+' Extinction depth \n')
        outFile.write('dl [um] = '+str(1.0e-4*2.0*pi*de)+' Extinction distance (Pend. length) \n')
        outFile.write('dth2 [urad] = '+str(1.0e6*dth_s*sqrt(2.0))+' double-crystal rocking curve for the symmetric reflection (sqrt(2)*dth_s) \n')
        #
        outFile.write('#-------------------------------------------------------------\n')        
        
        if cmd_opts.conv != 0:
           outFile.write('# Theory convolved with instrument resolution function:\n')
           if flag == 'a':
              outFile.write('R_max = '+str(rmax_ex)+ '\n')
              outFile.write('Delta_E [meV] = '+str(1.0e3*fwhm_ex)+ '\n')
              outFile.write('inst. resolution [meV] = '+str(1.0e3*fwhm0)+ '\n')
           elif flag == 'e':
              outFile.write('R_max = '+str(rmax_th)+ '\n')              
              outFile.write('dth [urad] = '+str(1.0e6*fwhm_th)+ '\n') 
              outFile.write('instrum. resolution [urad] = '+str(1.0e6*fwhm0)+ '\n')        
           outFile.write('#-------------------------------------------------------------\n')        
        #
        outFile.write('# Reflectivity/Transmissivity at Center: \n')
        outFile.write('Rc [%]  = '+str(Rc*100.0)+' Reflectivity \n')
        outFile.write('Tc [%]  = '+str(Tc*100.0)+' Transmissivity \n')
        if cmd_opts.z != '-1 -1':
            outFile.write('#-------------------------------------------------------------\n')
            outFile.write('#Mosaic block size assuming ramdom dislocation distribution approximation:\n')
            outFile.write('Size [um] = '+str(msize)+'\n')
            #
            outFile.write('Integrated characteristics:\n')
            outFile.write('Ri_int = '+str(Ri_int)+' Integrated Reflectivity - perfect crystal \n')
            outFile.write('Rmos1_int =' +str(Rmos1_int)+' Integrated Reflectivity - mosaic1 crystal (zero abs. solution)\n')                        
            #outFile.write('Rmos2_int =' +str(Rmos2_int)+' Int. Refl. mosaic asym.2 crystal \n')
            #outFile.write('Rpmos_int =' +str(Rpmos_int)+' Int. Refl. ideal mosaic crystal \n')
            outFile.write('Rmos1_int/Ri_int = '+str(Rmos1_int/Ri_int)+' Ratio of integrated reflectivities (mosaic to perfect)\n')
            #
            outFile.write('Reflectivity curve statistics:\n')
            outFile.write('Rmos1_max = '+str(rmax_mos1)+' Peak Reflectivity for mosaic crsytal\n')            
            if flag == 'a':
                outFile.write('Rmos1_fwhm [meV] = '+str(1.0e3*fwhm_mos1)+' Curve width FWHM for mosaic crystal\n')
            elif flag =='e':
                outFile.write('Rmos1_fwhm [urad] = '+str(1.0e6*fwhm_mos1)+' Curve width FWHM for mosaic crystal\n')     
            ###
            outFile.write('Approximations:\n')    
            if Gh>0:
                outFile.write('opt_d [um] =' +str(1.0e-4*opt_d)+' optimal crystal thickness in Laue \n')
                outFile.write('SF_max = ' +str(max(SF))+' Total scattering factor at max.\n')
            outFile.write('A = '+str(A)+' must be << 1 for small primary extinction \n')            
            outFile.write('Gs_mu ='+str(Gs_mu)+' must be << 1 for small secondary extinction \n')
        else:
            Rmos1 = zeros(len(Rplot))
            Tmos1 = zeros(len(Rplot))
            Wx_v  = zeros(len(Rplot))
            SF = zeros(len(Rplot))
            Norm = 0
            #Rmos2 = zeros(len(Rplot))
            #Tmos2 = zeros(len(Rplot))
        #
        outFile.close
######################################################################################################
        if cmd_opts.write is not None:
               header = '# '+ str(sys.argv) +'\n' \
                        +'# version '+__version__+' by Stanislav Stoupin\n' \
                        +'# columns: \n' \
                        +'# '+outh1+'Rplot Tplot SYplot rc0 Rmos1 Tmos1 Wx_v sig_v'+outh0+'\n'                   
               try:                
                    #writeFile(cmd_opts.write,header,outx1,Rplot,Tplot,SYplot,rc0,Rmos1,Tmos1,Rmos2,Tmos2,outx0)
                    writeFile(cmd_opts.write,header,outx1,Rplot,Tplot,SYplot,rc0,Rmos1,Tmos1,Wx_v*Norm,SF,outx0)
               #     
               except IOError as e:
                    fatalIOError(e)            
###### show figures ##################################################################################                                                        
        plt.show()
if __name__ == '__main__':
#	options, args = ParseArguments(sys.argv[1:])
	main()
